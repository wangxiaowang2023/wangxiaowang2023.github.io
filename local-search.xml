<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【other】docker相关基础介绍</title>
    <link href="/2024/01/08/docker%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/01/08/docker%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="【other】docker相关基础介绍介绍"><a href="#【other】docker相关基础介绍介绍" class="headerlink" title="【other】docker相关基础介绍介绍"></a>【other】docker相关基础介绍介绍</h1><h2 id="docker-后续有空补充"><a href="#docker-后续有空补充" class="headerlink" title="docker(后续有空补充)"></a>docker(后续有空补充)</h2><h2 id="docker-file（后续有空补充）"><a href="#docker-file（后续有空补充）" class="headerlink" title="docker file（后续有空补充）"></a>docker file（后续有空补充）</h2><h2 id="docker-compose-（简单介绍）"><a href="#docker-compose-（简单介绍）" class="headerlink" title="docker compose （简单介绍）"></a>docker compose （简单介绍）</h2><h3 id="docker-compose介绍"><a href="#docker-compose介绍" class="headerlink" title="docker compose介绍"></a>docker compose介绍</h3><p>docker compose 最开始是一个插件，后来官方采纳了这个开发者开发的开源插件</p><ol><li>用于定义和运行多容器docker 应用程序的工具，它使用YAML文件来配置应用程序的服务、网络和数据卷等组件，并通过一些简单的命令提供一种统一的方式来管理和操作这些容器</li><li>多容器应用：Docker Compose适用于构建和管理多容器的应用程序。你可以在同一个Compose文件中定义和管理应用程序中的多个服务，这些服务可以相互通信和协作。</li><li>声明式配置：通过使用YAML文件来定义Compose配置，你可以以声明式的方式描述应用程序的结构和配置。这使得配置易于阅读、理解和维护，并且可以轻松地重现整个应用程序环境。</li><li>简化的部署和管理：使用Docker Compose，你可以使用一条简单的命令来启动、停止、重启和删除整个应用程序。这使得应用程序的部署和管理变得更加简单和一致。</li><li>网络和卷配置：Docker Compose允许你定义应用程序中的网络和卷配置。你可以创建自定义网络，使得Compose中的服务可以相互通信。你还可以定义卷挂载，用于持久化数据或在容器之间共享文件。</li><li>扩展和覆盖：Compose配置支持扩展和覆盖，这意味着你可以在不同的环境中使用相同的Compose文件，只需根据需要覆盖某些配置。这使得在开发、测试和生产环境之间切换变得更加容易。</li></ol><p>服务定义：使用Docker Compose，你可以定义应用程序中的各个服务。每个服务都可以由一个或多个容器组成，可以设置容器的映像、端口映射、环境变量、卷挂载等配置</p><blockquote><p> 简单说就是：将你的某个应用程序所需要的服务，都编排到一个队列上去，通过docker compose来同一管理，这个时候你的这个compose内的容器都会处于同一个bridge桥网络下，</p><p>提供了一种简单且一致的方式来组织和操作容器化的应用程序，并使得在不同环境钟部署和运行应用程序变得更加容易</p></blockquote><h3 id="docker-compose-相关命令"><a href="#docker-compose-相关命令" class="headerlink" title="docker compose 相关命令"></a>docker compose 相关命令</h3><p>构建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose build<br>```<br>这个命令将根据Compose文件中定义的服务构建镜像。如果镜像已经存在，它将跳过构建步骤。<br></code></pre></td></tr></table></figure><p>启动容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up<br>```<br>这个命令将使用Compose文件启动定义的服务。如果Compose文件不存在，它将自动构建镜像并启动容器。<br></code></pre></td></tr></table></figure><p>启动容器（后台模式）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose up -d<br>```<br>这个命令将以后台模式启动容器，并将输出重定向到终端。<br></code></pre></td></tr></table></figure><p>查看Compose服务状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose config<br>```<br>这个命令将验证Compose文件的语法并显示解析后的配置。<br></code></pre></td></tr></table></figure><p>停止容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose down<br>```<br>这个命令将停止并删除Compose文件定义的所有容器、网络和卷。<br></code></pre></td></tr></table></figure><p>查看Compose文件配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose config<br>```<br>这个命令将验证Compose文件的语法并显示解析后的配置。<br></code></pre></td></tr></table></figure><p>执行Compose服务命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose exec &lt;service_name&gt; &lt;command&gt;<br>```<br>这个命令将在指定的服务容器中执行给定的命令。<br></code></pre></td></tr></table></figure><p>查看Compose服务日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Compose的服务日志：</span><br>docker-compose logs<br>```<br>这个命令将显示Compose文件中定义的所有服务的日志输出。<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看Compose的实时日志：</span><br>docker-compose logs -f<br>```<br>这个命令将以实时方式显示Compose文件中定义的所有服务的日志输出。你可以通过按下`Ctrl + C`来停止实时日志输出。<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看特定服务的日志</span><br>docker-compose logs &lt;service_name&gt;<br>```<br>这个命令将显示指定服务的日志输出。你可以替换`&lt;service_name&gt;`为Compose文件中定义的服务名称。<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看指定服务的实时日志：</span><br>docker-compose logs -f &lt;service_name&gt;<br>```<br>这个命令将以实时方式显示指定服务的日志输出。你可以替换`&lt;service_name&gt;`为Compose文件中定义的服务名称。<br></code></pre></td></tr></table></figure><h2 id="Kubernetes-K8S-简单介绍"><a href="#Kubernetes-K8S-简单介绍" class="headerlink" title="Kubernetes(K8S)简单介绍"></a>Kubernetes(K8S)简单介绍</h2><blockquote><p>开发只负责开发（拔掉开发的网线），其他杂七杂八的服务有运维通过K8S统一管理</p><p>比如说：开发连接数据库查询数据：只负责127.0.0.1本地连接即可，运维会在路由那里统一配置</p></blockquote><h3 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a>Kubernetes介绍</h3><p>Kubernetes（通常简称为K8s）是一个开源的容器编排平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一个强大的工具集，用于管理和编排容器化应用程序的各个方面，如部署、扩缩容、负载均衡、服务发现、自愈性等。</p><p>以下是网上抄的Kubernetes的一些关键概念和特点：</p><ol><li>容器编排：Kubernetes设计用于管理容器化应用程序。它可以自动部署和管理容器，确保它们在集群中正确运行，并根据需要进行扩展和收缩。</li><li>高可用性：Kubernetes提供高可用性的架构，通过在集群中的多个节点上运行容器副本，并自动重新调度故障容器，确保应用程序的可用性。</li><li>自动化扩缩容：Kubernetes允许根据应用程序的负载情况自动扩展或收缩容器的数量。这样，你可以根据需求快速适应流量变化，提高应用程序的弹性和性能。</li><li>服务发现和负载均衡：Kubernetes提供内建的服务发现和负载均衡机制。它可以自动分配稳定的网络地址给容器，并将流量均匀分发到后端服务，确保应用程序的可访问性和高可用性。</li><li>状态管理：Kubernetes允许你声明性地定义应用程序的状态和要求。它可以管理应用程序的部署、更新和回滚操作，确保应用程序按照预期运行。</li><li>配置和存储管理：Kubernetes提供配置管理和存储管理功能。它可以管理应用程序的配置文件和敏感信息，并支持各种存储选项，如持久卷和分布式存储系统。</li><li>健康检查和自愈性：Kubernetes可以对容器进行健康检查，并在容器出现故障时自动重新调度或替换它们。这提高了应用程序的可靠性和稳定性。</li><li>插件生态系统：Kubernetes拥有丰富的插件生态系统，支持各种功能和扩展，如日志管理、监控、安全性、网络策略等。</li></ol><p>通过使用Kubernetes，你可以更方便地管理和扩展容器化应用程序，提高应用程序的可靠性和弹性。它提供了一个统一的平台，用于自动化管理容器的各个方面，并支持在多云、混合云和本地环境中的部署。</p><p><img src="/../img/unsplash(1).jpg" alt="images1"></p>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>other</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】python装饰器的基础实现和常见装饰器</title>
    <link href="/2023/12/29/python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2023/12/29/python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><h1 id="应用场景及常见装饰器"><a href="#应用场景及常见装饰器" class="headerlink" title="应用场景及常见装饰器"></a>应用场景及常见装饰器</h1><ul><li>在Python接口自动化测试中，装饰器可以用于增强测试函数的功能或改变其行为。以下是一些可能使用的装饰器示例：</li></ul><h2 id="设置和清理环境【setup和teardown】"><a href="#设置和清理环境【setup和teardown】" class="headerlink" title="设置和清理环境【setup和teardown】"></a><strong>设置和清理环境</strong>【setup和teardown】</h2><h3 id="setup：用于在测试开始前初始化环境或配置。"><a href="#setup：用于在测试开始前初始化环境或配置。" class="headerlink" title="@setup：用于在测试开始前初始化环境或配置。"></a>@setup：用于在测试开始前初始化环境或配置。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTestRunner</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.setup_done = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setting up environment...&quot;</span>)<br>        <span class="hljs-comment"># 初始化环境或配置的代码...</span><br>        self.setup_done = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.setup_done:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Tearing down environment...&quot;</span>)<br>            <span class="hljs-comment"># 清理环境或资源的代码...</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">test_runner, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> test_runner.setup_done:<br>            test_runner.setup()<br>        <span class="hljs-keyword">return</span> func(test_runner, *args, **kwargs)<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.test_runner = CustomTestRunner()<br><span class="hljs-meta">    @setup</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.test_runner.setup_done, <span class="hljs-string">&quot;Setup should have been called&quot;</span><br>        <span class="hljs-comment"># 实现你的接口测试代码...</span><br><span class="hljs-comment"># 使用示例</span><br>test_case = MyTestCase()<br>test_case.test_my_api()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中，我们创建了一个名为CustomTestRunner的类，其中包含了一个setup方法用于初始化环境或配置。我们还定义了一个名为setup的装饰器，它会在调用被装饰的测试函数之前检查是否已经完成了设置，并在必要时调用setup方法。</p><p>在MyTestCase类中，我们使用@setup装饰器装饰了test_my_api方法。当我们创建一个MyTestCase实例并调用其test_my_api方法时，装饰器会确保在测试开始前调用了setup方法。</p><p>请注意，这个示例使用了一个自定义的测试运行器类（CustomTestRunner）和装饰器（@setup）。在实际项目中，你可能需要根据所使用的测试框架（如unittest、pytest等）来调整实现方式。例如，在unittest框架中，可以使用setUp和tearDown方法代替自定义的setup和teardown方法。</p></li></ul><h3 id="teardown：用于在测试结束后清理环境或资源。"><a href="#teardown：用于在测试结束后清理环境或资源。" class="headerlink" title="teardown：用于在测试结束后清理环境或资源。"></a>teardown：用于在测试结束后清理环境或资源。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTestRunner</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.setup_done = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setting up environment...&quot;</span>)<br>        <span class="hljs-comment"># 初始化环境或配置的代码...</span><br>        self.setup_done = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> self.setup_done:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Tearing down environment...&quot;</span>)<br>            <span class="hljs-comment"># 清理环境或资源的代码...</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">test_runner, *args, **kwargs</span>):<br>        result = func(test_runner, *args, **kwargs)<br>        test_runner.teardown()<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.test_runner = CustomTestRunner()<br><span class="hljs-meta">    @teardown</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">assert</span> self.test_runner.setup_done, <span class="hljs-string">&quot;Setup should have been called&quot;</span><br>        <span class="hljs-comment"># 实现你的接口测试代码...</span><br><span class="hljs-comment"># 使用示例</span><br>test_case = MyTestCase()<br>test_case.test_my_api()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中，我们创建了一个名为CustomTestRunner的类，其中包含了一个teardown方法用于清理环境或资源。我们还定义了一个名为teardown的装饰器，它会在被装饰的测试函数执行完毕后调用teardown方法。</p><p>在MyTestCase类中，我们使用@teardown装饰器装饰了test_my_api方法。当我们创建一个MyTestCase实例并调用其test_my_api方法时，装饰器会确保在测试结束后调用了teardown方法。</p><p>请注意，这个示例使用了一个自定义的测试运行器类（CustomTestRunner）和装饰器（@teardown）。在实际项目中，你可能需要根据所使用的测试框架（如unittest、pytest等）来调整实现方式。例如，在unittest框架中，可以使用setUp和tearDown方法代替自定义的setup和teardown方法。在pytest框架中，可以使用yield语句和fixture功能来实现类似的效果。</p></li></ul><h2 id="数据驱动测试"><a href="#数据驱动测试" class="headerlink" title="数据驱动测试"></a>数据驱动测试</h2><p>使用ddt库提供的装饰器，如@data、@unpack等，来实现数据驱动的测试。</p><p>@data和@unpack是ddt（Data-Driven Tests）库提供的装饰器，用于实现数据驱动的测试。以下是一个使用@data和@unpack装饰器的示例：</p><ul><li><p>首先，确保已经安装了ddt库：pip install ddt</p></li><li><p>然后，可以使用以下代码示例：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> ddt <span class="hljs-keyword">import</span> ddt, data, unpack<br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @data(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;invalid_password&quot;</span>, <span class="hljs-number">401</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    </span>)</span><br><span class="hljs-meta">    @unpack</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>(<span class="hljs-params">self, username, password, expected_status_code</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/login&quot;</span><br>        payload = &#123;<span class="hljs-string">&quot;username&quot;</span>: username, <span class="hljs-string">&quot;password&quot;</span>: password&#125;<br>        response = requests.post(url, json=payload)<br>        self.assertEqual(response.status_code, expected_status_code)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们使用@data装饰器定义了一个包含多个测试数据集的元组列表。每个元组代表一个特定的测试场景，包括用户名、密码和预期的HTTP状态码。</p><p>使用@unpack装饰器，我们可以将元组中的值直接解包并作为测试函数的参数。这样在测试函数内部，我们就可以直接使用这些变量名，而不需要通过索引来访问它们。</p><p>在test_login方法中，我们根据提供的用户名、密码和预期状态码发送登录请求，并验证响应的状态码是否与预期相符。</p><p>通过这种方式，我们可以使用@data和@unpack装饰器轻松地为同一个测试函数定义多个不同的测试场景，从而提高测试覆盖率和代码的可读性。</p></li></ul><h2 id="数据类装饰器，-dataclass"><a href="#数据类装饰器，-dataclass" class="headerlink" title="数据类装饰器，@dataclass"></a>数据类装饰器，@dataclass</h2><p>把一个类装饰成一个数据类–方便后面取值，后面就可以直接调用此类的属性拿到值了，不需要像字典一样使用点get()或者[‘键名’]的方式去拿数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass<br><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<span class="hljs-comment"># 将这个类装饰成数据类</span><br>    name: <span class="hljs-built_in">str</span><span class="hljs-comment"># 定义数据的类型</span><br>    age: <span class="hljs-built_in">int</span><br>    email: <span class="hljs-built_in">str</span><br><br><span class="hljs-comment"># 创建对象 实例化对象，也就是实例化数据，</span><br>person = Person(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;alice@example.com&quot;</span>)<br><span class="hljs-built_in">print</span>(person.name)    <span class="hljs-comment"># 输出: Alice</span><br><span class="hljs-built_in">print</span>(person.age)     <span class="hljs-comment"># 输出: 25</span><br><span class="hljs-built_in">print</span>(person.email)   <span class="hljs-comment"># 输出: alice@example.com</span><br><span class="hljs-comment"># 也可以通过**的方式传进去，更美观</span><br>person2_dict = &#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>    <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;Bob@example.com&quot;</span><br>&#125;<br>person2 = Person(**person2_dict)<br><span class="hljs-comment"># 访问属性</span><br><br><span class="hljs-built_in">print</span>(person2.name) <span class="hljs-comment"># 输出: Bob</span><br><span class="hljs-built_in">print</span>(person2.age)  <span class="hljs-comment"># 输出: 30</span><br><span class="hljs-built_in">print</span>(person2.email)  <span class="hljs-comment"># 输出: Bob@example.com</span><br><br></code></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="timer：测量测试函数的执行时间。"><a href="#timer：测量测试函数的执行时间。" class="headerlink" title="@timer：测量测试函数的执行时间。"></a>@timer：测量测试函数的执行时间。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        start_time = time.time() <span class="hljs-comment"># 记录开始时间</span><br>        result = func(*args, **kwargs)<br>        end_time = time.time()<span class="hljs-comment"># 记录结束时间</span><br>        <span class="hljs-comment"># 记录运行时间</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;func.__name__&#125;</span> executed in <span class="hljs-subst">&#123;end_time - start_time:<span class="hljs-number">.6</span>f&#125;</span> seconds&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @timer</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 实现你的接口测试代码...</span><br>        time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 模拟耗时操作</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为timer的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们首先记录开始时间，然后调用原始函数并获取其结果，最后记录结束时间。</p><p>我们计算并打印出被装饰的函数的执行时间。</p><p>在MyTestCase类中，我们使用@timer装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会测量并打印出该方法的执行时间。</p><p>请注意，这个timer装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望将执行时间记录到日志文件中，或者在测试报告中包含执行时间信息等。</p></li></ul><h3 id="profile（使用cProfile库）：进行CPU性能分析。"><a href="#profile（使用cProfile库）：进行CPU性能分析。" class="headerlink" title="@profile（使用cProfile库）：进行CPU性能分析。"></a>@profile（使用cProfile库）：进行CPU性能分析。</h3><p>以下是一个使用@profile装饰器（配合cProfile库）进行CPU性能分析的简单示例：</p><ul><li><p>首先，确保已经安装了cProfile库 pip install cProfile</p></li><li><p>然后，可以使用以下代码示例：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> cProfile<br><span class="hljs-keyword">from</span> pstats <span class="hljs-keyword">import</span> Stats<br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @profile</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    profiler = cProfile.Profile()<br>    test_case = MyTestCase()<br>    test_case.test_my_api()<br>    profiler.create_stats()<br>    stats = Stats(profiler)<br>    stats.sort_stats(<span class="hljs-string">&#x27;cumulative&#x27;</span>)<br>    stats.print_stats()<br></code></pre></td></tr></table></figure><p>在这个例子中：</p><p>我们使用@profile装饰器装饰了test_my_api方法。当运行这个测试用例时，cProfile库会记录该方法的CPU性能数据。</p><p>在测试用例执行完毕后，我们创建了一个Stats对象，并将Profiler的统计数据传递给它。</p><p>我们调用sort_stats方法对统计数据进行排序。在这个例子中，我们选择了按累计时间排序。</p><p>最后，我们调用print_stats方法打印出性能分析结果。</p><p>请注意，这个示例只是一个基本的使用方式，实际使用中可能需要根据具体需求进行调整。例如，你可能希望将性能分析结果保存到文件中，或者使用更复杂的统计和过滤选项等。另外，cProfile库主要用于CPU性能分析，如果你需要进行内存或其他资源的性能分析，可能需要使用其他工具或库。</p><h2 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a><strong>日志记录</strong></h2><h3 id="log-test：记录测试的开始和结束，以及测试结果。"><a href="#log-test：记录测试的开始和结束，以及测试结果。" class="headerlink" title="@log_test：记录测试的开始和结束，以及测试结果。"></a>@log_test：记录测试的开始和结束，以及测试结果。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLogger</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_start</span>(<span class="hljs-params">self, test_name</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Starting test: <span class="hljs-subst">&#123;test_name&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log_end</span>(<span class="hljs-params">self, test_name, result</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Ending test: <span class="hljs-subst">&#123;test_name&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> result:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test passed.&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Test failed.&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">log_test</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">test_logger, *args, **kwargs</span>):<br>        test_name = func.__name__<br>        test_logger.log_start(test_name)<br>        result = func(test_logger, *args, **kwargs)<br>        test_logger.log_end(test_name, result)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.test_logger = TestLogger()<br><span class="hljs-meta">    @log_test</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self, test_logger</span>):<br>        url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为TestLogger的类，它包含两个方法：log_start和log_end，分别用于记录测试的开始和结束，以及测试结果。</p><p>我们定义了一个名为log_test的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们首先获取被装饰的函数名，然后调用log_start方法记录测试的开始。</p><p>我们调用原始函数并获取其结果。</p><p>我们调用log_end方法记录测试的结束，并传递测试结果。</p><p>在MyTestCase类中，我们创建了一个TestLogger实例，并在setUpClass方法中设置为类变量。</p><p>我们使用@log_test装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会记录测试的开始和结束，以及测试结果。</p><p>请注意，这个log_test装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望将日志信息写入文件，或者使用更复杂的日志格式和级别等。另外，这个示例中的日志输出是简单的文本形式，如果你需要更丰富的日志功能，可以考虑使用Python的logging模块。</p></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a><strong>异常处理</strong></h2><h3 id="catch-exceptions：捕获并处理测试函数中可能抛出的异常。"><a href="#catch-exceptions：捕获并处理测试函数中可能抛出的异常。" class="headerlink" title="@catch_exceptions：捕获并处理测试函数中可能抛出的异常。"></a>@catch_exceptions：捕获并处理测试函数中可能抛出的异常。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">catch_exceptions</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Exception caught during test: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @catch_exceptions</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为catch_exceptions的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们使用try-except语句包裹原始函数的调用。如果在执行原始函数时抛出了异常，我们将捕获这个异常，并打印出异常信息。</p><p>如果捕获到异常，我们返回False，表示测试失败。否则，我们返回原始函数的返回值。</p><p>在MyTestCase类中，我们使用@catch_exceptions装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会捕获并处理该方法中可能抛出的异常。</p><p>请注意，这个catch_exceptions装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的异常进行不同的处理，或者在捕获异常后执行一些清理操作等。另外，虽然这个装饰器可以帮助我们在测试函数中捕获和处理异常，但在编写测试代码时，通常建议明确预期可能会抛出的异常，并使用assertRaises等断言来验证它们。这样可以提供更清晰的测试意图和更好的错误消息。</p></li></ul><h2 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h2><h3 id="retry：在测试失败时自动重试指定次数"><a href="#retry：在测试失败时自动重试指定次数" class="headerlink" title="@retry：在测试失败时自动重试指定次数"></a>@retry：在测试失败时自动重试指定次数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">retry</span>(<span class="hljs-params">attempts=<span class="hljs-number">3</span>, delay=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(attempts):<br>                <span class="hljs-keyword">try</span>:<br>                    <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test failed on attempt <span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">if</span> i &lt; attempts - <span class="hljs-number">1</span>:<br>                        time.sleep(delay)<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">f&quot;Test failed after <span class="hljs-subst">&#123;attempts&#125;</span> attempts&quot;</span>)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @retry(<span class="hljs-params">attempts=<span class="hljs-number">3</span>, delay=<span class="hljs-number">2</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为retry的装饰器，它接受两个可选参数：attempts（重试次数，默认为3）和delay（每次重试之间的延迟时间，默认为1秒）。</p><p>retry装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们使用一个循环来尝试调用原始函数。如果在执行原始函数时抛出了异常，我们将捕获这个异常，并打印出异常信息。</p><p>如果捕获到异常并且还有剩余的重试次数，我们将暂停一段时间（由delay参数指定），然后再次尝试调用原始函数。</p><p>如果所有重试都失败了，我们将重新抛出最后一个捕获到的异常。</p><p>在MyTestCase类中，我们使用@retry装饰器装饰了test_my_api方法，并指定了重试次数和延迟时间。当我们运行这个测试用例时，装饰器会自动重试该方法，直到成功或达到最大重试次数。</p><p>请注意，这个retry装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的异常进行不同的重试策略，或者在重试之间执行一些清理操作等。另外，虽然重试机制可以在某些情况下帮助处理临时性故障，但过度依赖重试可能会掩盖系统中的根本问题。因此，在使用重试机制时应谨慎考虑其适用性和可能的副作用。</p></li></ul><h2 id="权限和认证"><a href="#权限和认证" class="headerlink" title="权限和认证"></a>权限和认证</h2><h3 id="with-auth：为测试函数添加特定的认证信息或权限"><a href="#with-auth：为测试函数添加特定的认证信息或权限" class="headerlink" title="@with_auth：为测试函数添加特定的认证信息或权限"></a>@with_auth：为测试函数添加特定的认证信息或权限</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthManager</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, username, password</span>):<br>        self.username = username<br>        self.password = password<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">authenticate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 这里是实际的认证逻辑，例如发送HTTP请求获取访问令牌等</span><br>        <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">with_auth</span>(<span class="hljs-params">username, password</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            auth_manager = AuthManager(username, password)<br>            auth_manager.authenticate()<br>            <span class="hljs-keyword">return</span> func(auth_manager, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @with_auth(<span class="hljs-params"><span class="hljs-string">&quot;test_user&quot;</span>, <span class="hljs-string">&quot;test_password&quot;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self, auth_manager</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        headers = &#123;<span class="hljs-string">&quot;Authorization&quot;</span>: auth_manager.access_token&#125;  <span class="hljs-comment"># 假设auth_manager对象有一个access_token属性</span><br>        response = requests.get(url, headers=headers)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为AuthManager的类，它用于管理认证信息和执行认证操作。</p><p>我们定义了一个名为with_auth的装饰器，它接受两个参数：username和password。</p><p>with_auth装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们创建了一个AuthManager实例，并使用提供的用户名和密码进行初始化。</p><p>我们调用authenticate方法对AuthManager实例进行认证。</p><p>我们将认证后的AuthManager实例传递给原始函数，并返回其结果。</p><p>在MyTestCase类中，我们使用@with_auth装饰器装饰了test_my_api方法，并提供了用户名和密码。当我们运行这个测试用例时，装饰器会先执行认证操作，然后将认证后的AuthManager实例传递给test_my_api方法。</p><p>请注意，这个with_auth装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能需要处理更复杂的认证流程，或者支持多种不同的认证方式等。另外，这个示例中的AuthManager类和authenticate方法只是为了演示目的而编写的，实际使用时应替换为实际的认证逻辑和数据。</p></li></ul><h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><h3 id="parametrize（使用pytest库）：为测试函数提供多个参数组合"><a href="#parametrize（使用pytest库）：为测试函数提供多个参数组合" class="headerlink" title="@parametrize（使用pytest库）：为测试函数提供多个参数组合"></a>@parametrize（使用pytest库）：为测试函数提供多个参数组合</h3><p>以下是一个使用@pytest.mark.parametrize装饰器（来自pytest库）为测试函数提供多个参数组合的简单示例：</p><p>首先，确保已经安装了pytest库：pip install pytest</p><p>然后，可以使用以下代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;username, password, expected_status_code&quot;</span>, [</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>, <span class="hljs-number">200</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;invalid_password&quot;</span>, <span class="hljs-number">401</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">        (<span class="hljs-params"><span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-number">400</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-meta">    ]</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login</span>(<span class="hljs-params">self, username, password, expected_status_code</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/login&quot;</span><br>        payload = &#123;<span class="hljs-string">&quot;username&quot;</span>: username, <span class="hljs-string">&quot;password&quot;</span>: password&#125;<br>        response = requests.post(url, json=payload)<br>        <span class="hljs-keyword">assert</span> response.status_code == expected_status_code<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    pytest.main()<br>    <br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们使用@pytest.mark.parametrize装饰器装饰了test_login方法。该装饰器接受两个参数：一个参数名列表和一个参数值列表。</p><p>参数名列表包含了被装饰的测试函数期望接收的参数名称。</p><p>参数值列表是一个包含多个元组的列表，每个元组代表一组特定的参数值组合。</p><p>当我们运行这个测试用例时，pytest会为test_login方法生成多个实例，每个实例使用一组不同的参数值。这样，我们可以用一种简洁的方式为同一个测试函数提供多个不同的输入和预期输出。</p><p>请注意，虽然这个例子中我们没有使用unittest.TestCase类，但你可以将这个测试用例与unittest.TestCase结合使用，只需要在测试类中继承unittest.TestCase，并使用unittest的断言方法即可。另外，pytest提供了许多其他功能和装饰器，可以根据需要进行探索和使用。</p></li></ul><h2 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h2><h3 id="skip-if：在满足特定条件时跳过测试"><a href="#skip-if：在满足特定条件时跳过测试" class="headerlink" title="@skip_if：在满足特定条件时跳过测试"></a>@skip_if：在满足特定条件时跳过测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">skip_if</span>(<span class="hljs-params">condition</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">if</span> condition:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test skipped because condition is satisfied: <span class="hljs-subst">&#123;condition&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @skip_if(<span class="hljs-params">os.environ.get(<span class="hljs-params"><span class="hljs-string">&quot;SKIP_FLAKY_TESTS&quot;</span>, <span class="hljs-literal">False</span></span>)</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_flaky_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/flaky-resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为skip_if的装饰器，它接受一个参数：一个表示条件的表达式。</p><p>skip_if装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们检查提供的条件是否为真。如果条件为真，我们将打印一条消息并直接返回，从而跳过测试。否则，我们将调用原始函数并返回其结果。</p><p>在MyTestCase类中，我们使用@skip_if装饰器装饰了test_flaky_api方法，并提供了一个条件表达式。这个条件表达式检查环境变量”SKIP_FLAKY_TESTS”是否存在且值为True。如果我们设置了这个环境变量，那么这个测试将被跳过。</p><p>请注意，这个skip_if装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的条件使用不同的装饰器，或者在跳过测试时执行一些清理操作等。另外，虽然跳过测试可以在某些情况下避免不必要的失败和复杂性，但过度依赖跳过机制可能会掩盖系统中的问题。因此，在使用跳过机制时应谨慎考虑其适用性和可能的副作用。</p></li></ul><h3 id="run-only-if：在满足特定条件时执行测试"><a href="#run-only-if：在满足特定条件时执行测试" class="headerlink" title="@run_only_if：在满足特定条件时执行测试"></a>@run_only_if：在满足特定条件时执行测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_only_if</span>(<span class="hljs-params">condition</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> condition:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test skipped because condition is not satisfied: <span class="hljs-subst">&#123;condition&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">return</span> func(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorator<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @run_only_if(<span class="hljs-params">os.environ.get(<span class="hljs-params"><span class="hljs-string">&quot;RUN_SPECIFIC_TESTS&quot;</span>, <span class="hljs-literal">False</span></span>)</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_specific_api</span>(<span class="hljs-params">self</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/specific-resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    unittest.main()<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为run_only_if的装饰器，它接受一个参数：一个表示条件的表达式。</p><p>run_only_if装饰器内部定义了一个新的装饰器函数（即decorator），它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们检查提供的条件是否为真。如果条件为假，我们将打印一条消息并直接返回，从而跳过测试。否则，我们将调用原始函数并返回其结果。</p><p>在MyTestCase类中，我们使用@run_only_if装饰器装饰了test_specific_api方法，并提供了一个条件表达式。这个条件表达式检查环境变量”RUN_SPECIFIC_TESTS”是否存在且值为True。如果我们设置了这个环境变量，那么这个测试将被执行。</p><p>请注意，这个run_only_if装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望对不同类型的条件使用不同的装饰器，或者在执行测试前执行一些初始化操作等。另外，虽然选择性地执行测试可以在某些情况下提高测试效率和针对性，但过度依赖这种机制可能会导致部分测试被忽视或遗漏。因此，在使用run_only_if装饰器时应谨慎考虑其适用性和可能的副作用。</p></li></ul><h2 id="报告和统计"><a href="#报告和统计" class="headerlink" title="报告和统计"></a><strong>报告和统计</strong></h2><h3 id="report-result：自定义测试结果的报告格式或统计数据"><a href="#report-result：自定义测试结果的报告格式或统计数据" class="headerlink" title="@report_result：自定义测试结果的报告格式或统计数据"></a>@report_result：自定义测试结果的报告格式或统计数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomTestResult</span>(unittest.TestResult):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.success_count = <span class="hljs-number">0</span><br>        self.failure_count = <span class="hljs-number">0</span><br>        self.error_count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addSuccess</span>(<span class="hljs-params">self, test</span>):<br>        <span class="hljs-built_in">super</span>().addSuccess(test)<br>        self.success_count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addFailure</span>(<span class="hljs-params">self, test, err</span>):<br>        <span class="hljs-built_in">super</span>().addFailure(test, err)<br>        self.failure_count += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">addError</span>(<span class="hljs-params">self, test, err</span>):<br>        <span class="hljs-built_in">super</span>().addError(test, err)<br>        self.error_count += <span class="hljs-number">1</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">report_result</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        result = CustomTestResult()<br>        test_method = <span class="hljs-built_in">getattr</span>(args[<span class="hljs-number">0</span>], func.__name__)<br>        test_method(result)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Test results: <span class="hljs-subst">&#123;result.success_count&#125;</span> successes, <span class="hljs-subst">&#123;result.failure_count&#125;</span> failures, <span class="hljs-subst">&#123;result.error_count&#125;</span> errors&quot;</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTestCase</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUpClass</span>(<span class="hljs-params">cls</span>):<br>        cls.base_url = <span class="hljs-string">&quot;http://example.com/api&quot;</span><br><span class="hljs-meta">    @report_result</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_my_api</span>(<span class="hljs-params">self, result</span>):<br>        url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.base_url&#125;</span>/resource&quot;</span><br>        response = requests.get(url)<br>        self.assertEqual(response.status_code, <span class="hljs-number">200</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    suite = unittest.TestLoader().loadTestsFromTestCase(MyTestCase)<br>    runner = unittest.TextTestRunner()<br>    runner.run(suite)<br></code></pre></td></tr></table></figure><ul><li><p>在这个例子中：</p><p>我们定义了一个名为CustomTestResult的类，它继承自unittest.TestResult并添加了自定义的计数器属性。</p><p>我们重写了addSuccess、addFailure和addError方法，以便在测试成功、失败或出现错误时更新自定义计数器。</p><p>我们定义了一个名为report_result的装饰器，它接受一个函数作为参数，并返回一个新的函数（即wrapper）。</p><p>在wrapper函数内部，我们创建了一个CustomTestResult实例，并获取被装饰的测试方法。</p><p>我们调用测试方法并将CustomTestResult实例传递给它，以便收集测试结果。</p><p>我们打印出自定义的测试结果报告，包括成功、失败和错误的数量。</p><p>在MyTestCase类中，我们使用@report_result装饰器装饰了test_my_api方法。当我们运行这个测试用例时，装饰器会收集测试结果并打印出自定义的报告。</p><p>请注意，这个report_result装饰器只是一个简单的示例，实际使用中可能需要根据具体需求进行调整。例如，你可能希望生成更复杂的报告格式，或者将报告保存到文件或数据库等。另外，虽然这个例子中我们没有直接使用unittest.TextTestRunner来运行测试，但在实际项目中，你可以将自定义的CustomTestResult类与unittest.TextTestRunner结合使用，以实现更灵活的测试报告功能。</p><p><img src="/img/neom-kirkdJn(2).jpg" alt="unsplash"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【other】临时记录用的</title>
    <link href="/2023/12/29/%E5%B9%B3%E5%B8%B8%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/29/%E5%B9%B3%E5%B8%B8%E4%B8%80%E4%BA%9B%E9%9B%B6%E6%95%A3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="临时记录用的"><a href="#临时记录用的" class="headerlink" title="临时记录用的"></a>临时记录用的</h1><h1 id="shell命令行"><a href="#shell命令行" class="headerlink" title="shell命令行"></a>shell命令行</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep ‘查找内容’ -n </p><ul><li>-n 显示匹配内容的行号</li></ul><p>grep ‘查找内容’ -v</p><ul><li>-v 是反选，就是不展示grep的内容</li></ul><p>grep ‘查找内容’ -A  10 注意大写的字母ABC</p><ul><li>-A是指：after 查找内容后10行的内容，</li><li>-B是指：before 查找内容的前多少行的内容</li><li>-C是指：context.查找内容的前后各多少行</li></ul><p>grep ^内容 </p><ul><li>^是匹配以内容开头的行，注意是行</li></ul><p>grep 内容$</p><ul><li>返回以什么内容结尾的行，</li></ul><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>修改文件内容用，</p><ul><li><p>不修改文件内容用-e </p><ul><li>sed -e  ‘ 旧内容  新内容 ‘  xx文件</li></ul></li><li><p>修改文件内容用 -i </p><ul><li>sed -i ‘旧内容  新内容 ‘ xx文件</li></ul></li><li><p>sed -e 后面的接的指令</p><ul><li>a 新增</li><li>c 取代</li><li>d 删除</li><li>i 插入</li><li>p 打印</li></ul></li></ul><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>address: cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755</p><p>取出address的值</p><p>就用awk ‘&#x2F;address&#x2F;{print $2}’  得到cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755</p><p>原理是：其中 <code>/address/</code> 表示匹配包含 <code>address</code> 的行，<code>&#123;print $2&#125;</code> 表示输出该行的第二个字段。输出结果为 <code>cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755</code></p><p>$2 里面的2可以换成1、3、4等任何数字，数字表示你匹配到的字段的后几位开始的数据，例如你匹配到的cosmosxxxxxx是在address的后面的3个字符后才出现的，那就是$3 第四个字符出现的就是$4，以此类推</p><p><img src="/img/awk2.png" alt="image-20230615110717966"></p><p>awk ‘：’‘ {pring $2}’</p><p>输出该行第二个字段</p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps <br>CONTAINER ID   IMAGE                             COMMAND                   CREATED       STATUS                  PORTS                                                           NAMES<br>a7a584dfd04a   django-vue-admin_dvadmin-django   &quot;/backend/docker_sta…&quot;   13 days ago   Up Less than a second   0.0.0.0:8000-&gt;8000/tcp, :::8000-&gt;8000/tcp                       dvadmin-django<br>286cc8be5d9f   mysql:5.7                         &quot;docker-entrypoint.s…&quot;   13 days ago   Up Less than a second   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp            dvadmin-mysql<br>1cb7df749dec   mysql:8.0.30                      &quot;docker-entrypoint.s…&quot;   2 weeks ago   Up Less than a second   33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp            django_mysql<br>93b06a5f97a1   portainer/portainer-ce:latest     &quot;/portainer&quot;              2 weeks ago   Up Less than a second   8000/tcp, 9443/tcp, 0.0.0.0:1009-&gt;9000/tcp, :::1009-&gt;9000/tcp   portainer<br><br>docker ps | awk &#x27;&#123;print $1&#125;&#x27; # 使用 awk 工具对前一个命令的输出进行处理，提取每行的第一个字段（以空格为分隔符），并将其打印出来<br>CONTAINER<br>a7a584dfd04a<br>286cc8be5d9f<br>1cb7df749dec<br>93b06a5f97a1<br>docker ps | awk &#x27;&#123;print $1&#125;&#x27;|tail +2  # 从第二个开始取<br>a7a584dfd04a<br>286cc8be5d9f<br>1cb7df749dec<br>93b06a5f97a1<br>docker stop $(docker ps | awk &#x27;&#123;print $1&#125;&#x27;|tail +2) # 停止容器<br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">address: cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755<br>取出address的值<br><span class="hljs-meta prompt_"># </span><span class="language-bash">就用</span><br>awk ‘/address/&#123;print $2&#125;’  得到cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755<br><br>原理是：其中 `/address/` 表示匹配包含 `address` 的行，`&#123;print $2&#125;` 表示输出该行的第二个字段。输出结果为 `cosmos1g920yuxdmqtfxg4w8a0j9sgaazfryr2cx0d755`<br></code></pre></td></tr></table></figure><p>三剑客的功能非常强大，但我们只需要掌握他们分别擅长的领域即可：<strong>grep</strong>擅长查找功能，<strong>sed</strong>擅长取行和替换。<strong>awk</strong>擅长取列。</p><p>vscode远程连接到远程服务器后，无修改文件权限</p><p>Failed to save “test’’: Unable to write file (NoPermissions (FileSystemError): Error: EACCES: permission denied, open…<br>修改权限：<br>sudo chown -R myuser &#x2F;path&#x2F;to&#x2F;folder<br>other：<br>所有conda命令必须在没有超级用户特权的情况下运行。</p><h1 id="pytest"><a href="#pytest" class="headerlink" title="pytest"></a>pytest</h1><p>命令行执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">pytest -s ./wangtestcase/testwang.py  --log-level=debug  --alluredir=./wangtestcase/report  --clean-alluredir<br><br>pytest -s ./checklist/test_delegate.py::TestRegionDelegate::test_region_delegate <br><br></code></pre></td></tr></table></figure><p>将allure报告改成html文件</p><blockquote><p> allure generate .&#x2F;wangtestcase&#x2F;report&#x2F;json -o .&#x2F;wangtest&#x2F;report&#x2F;html</p></blockquote><p>查看allure报告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shelll">allure serve ./wangtestcase/report/json<br></code></pre></td></tr></table></figure><p>加参数 -s 不打印细节</p><blockquote><p>pytest testcase.py -s</p></blockquote><p>加参数 - m 组名</p><blockquote><p>在对应的测试函数上面加装饰器如：</p><p>@pytest.mark.maoyan</p><p>def test001(self):</p><p>​assert 1 +1 &#x3D;&#x3D;2</p><p>命令行运行的时候 pytest testcase.py -s -m&#x3D;maoyan</p><p>这个是个就只会执行带maoyan装饰器的用例</p></blockquote><p>加参数 -maxfail&#x3D;1 出现1个失败用例时就终止测试</p><blockquote><p>maxfail&#x3D;1：出现1个失败就终止测试<br>如：pytest testcase.py –maxfail&#x3D;1</p></blockquote><p>加参数 –html&#x3D;.&#x2F;test&#x2F;test.html 生成html报告且指定保存路径（需要先安装pytest-html）</p><blockquote><p>–html&#x3D;路径&#x2F;report.html：生成xml&#x2F;html格式测试报告<br>如：pytest testcase.py –html&#x3D;.&#x2F;report.html</p></blockquote><p>加参数 –reruns&#x3D;2 一旦用例运行失败，重新再跑一次（需要先安装pytest-rerunfailures）</p><blockquote><p>如：pytest testcase.py –reruns&#x3D;2</p></blockquote><p>pytest的ini配置文件</p><p>位置：可以用全局搜索pytest.ini把这个文件搜出来</p><p>作用：指定Pytest的运行方式 （在cmd输入pytest 后，会读取Pytest.ini中的配置信息，按指定的方式去运行）</p><p>也可以使用pytest -h 查看pytest.ini的设置选项，</p><p>常用设置选项如下</p><blockquote><p>[pytest]<br>addopts &#x3D; -s … #可添加多个命令行参数，用空格分隔<br>testpaths &#x3D; …&#x2F;pytestproject #测试用例文件夹，可自己配置，…&#x2F;pytestproject为上一层的pytestproject文件夹。<br>python_files &#x3D; test*.py #配置测试搜索的模块文件名称<br>python_classes &#x3D; Test* #配置测试搜索的测试类名<br>python_funtions &#x3D; test #配置测试搜索的测试函数名</p><p>reruns &#x3D; 3 # 默认重复3次</p><p>reruns_delay &#x3D; 5 </p><p>示例如下：<br>[pytest]<br>addopts &#x3D; -s –html&#x3D;.&#x2F;report.html<br>testpaths &#x3D; …&#x2F;pytestproject<br>python_files &#x3D; test*.py<br>python_classes &#x3D; Test*<br>python_funtions &#x3D; test*</p><p>filterwarnings &#x3D;<br>    ignore  # 忽略警告</p></blockquote><p>pytest前置和后置方法</p><blockquote><p>setup、teardown、setup_class、teardown_class 注意，是小写字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_class</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类级别的前置&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown_class</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类级别的后置&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;每次用例前置执行&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">teardown</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;每次用例后置执行&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote><p>fixtrue修饰器</p><p>作用：标记的方法通常用于在其他函数、模块、类或者整个工程调用时会优先执行，通常会被用于完成预置处理和重复操作。例如：登录，执行SQL等操作。</p><p>fixure前置运行</p><p>运行范围：fixture(scope &#x3D; ‘function’,autose&#x3D;Ture) </p><blockquote><p>@pytest.fixture(scope &#x3D; ‘function’,autose&#x3D;Ture)</p><p>def login( ) :</p><p>​print(“登录系统”)</p><p>scope &#x3D; ‘function’该文件下的所有的测试方法，在执行前都会运行一次这个前置方法，不管哪个类里面还是外面</p><p>如果装饰器是</p><p>@pytest.fixture(scope&#x3D;’class’,autouse&#x3D;True)</p><p>那就是每个测试类在执行前会执行一次该方法</p><p>或者还有一种方式是，在对应的类的前面加装饰器@pytest.mark.usefixtures(‘login’) 括号里面放对应函数，</p><p>也可以在N个用例中执行某一个函数，只要在对应测试函数的传参里面加一个对应的方法名称就可以，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br> <br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;登录系统&#x27;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_01</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试用例一&#x27;</span>)<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase1</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_03</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试用例三&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test04</span>(<span class="hljs-params">self,login</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试用例四&#x27;</span>)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&#x27;-s&#x27;</span>,<span class="hljs-string">&#x27;pytest-demo.py&#x27;</span>])<br>    这样就指挥在test04这个测试方法上 运行这个login函数方法了，<br></code></pre></td></tr></table></figure></blockquote><p>fixture之params参数化： 传入的参数可以是list、tuple、字典列表、字典元组</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_yaml</span>():<br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>]<br> <br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">params=read_yaml(<span class="hljs-params"></span>)</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_param</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> request.param<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test01</span>(<span class="hljs-params">get_param</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试用例：&#x27;</span>+get_param)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&#x27;-s&#x27;</span>,<span class="hljs-string">&#x27;pytest-demo.py&#x27;</span>])<br>    <br></code></pre></td></tr></table></figure><p>注意：</p><p>“1.此例中test01方法被执行了三次，分别使用的数据为’1’,’2’,’3’，此结果类似于ddt数据驱动的功能。特别注意：这里的request参数名是固定的，然后request.param的param没有s哦。”</p><p>2.可以把return request.param改成yield request.param，yield也是返回的意思，它和return的区别在于return返回后后面不能接代码，但是yield返回后，后面还可以接代码。</p></blockquote><p>Fixture其他参数：</p><blockquote><p>1.autouse参数：自动执行，上面的示例已经用到了。</p><p>2.ids参数：ids参数是给每一项params参数设置自定义名称用的，意义不大。</p><p>3.name参数：相对于把被fixture标记的方法重命名，意义不大。如下图所示案例：</p></blockquote><p>使用@pytest.mark.parametrize( )方法实现参数化 <strong>#常用</strong></p><p>方法详情：pytest.mark.parametrize(argnames,argvalues,indirect&#x3D;False,ids&#x3D;None,scope&#x3D;None )</p><p>常用传参：</p><p>argnames：参数名，</p><p>argvalues:参数值 ,可以为list和tuple，或者字典列表，字典元祖等）,参数值有N个，用例就会执行N次。</p><p>使用方式一：**#常用**</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br> <br>lis = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;zhangsan&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-string">&#x27;18&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;sex&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>&#125;]<br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;caseinfo&#x27;</span>,lis</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test01</span>(<span class="hljs-params">caseinfo</span>):<br>    <span class="hljs-built_in">print</span>(caseinfo)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&#x27;-s&#x27;</span>,<span class="hljs-string">&#x27;pytest-demo.py&#x27;</span>])<br></code></pre></td></tr></table></figure><p>这里的’caseinfo’就是argnames,也可以写成argnames&#x3D; ‘caseinfo’ </p><p>同理，lis就是取值，也可以写成argvalues&#x3D;lis</p></blockquote><p>使用方式二 ：类似于@unpack解包功能解开对应的数据组</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br> <br>lis = [(<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;123&#x27;</span>),(<span class="hljs-string">&#x27;admin1&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>)]<br><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&#x27;username,password&#x27;</span>,lis</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test01</span>(<span class="hljs-params">username,password</span>):<br>    <span class="hljs-built_in">print</span>(username,password)<br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&#x27;-s&#x27;</span>,<span class="hljs-string">&#x27;pytest-demo.py&#x27;</span>])<br></code></pre></td></tr></table></figure></blockquote><p>pytest 错误校验</p><p>如果正常的引发异常则通过，没有抛出异常或抛出的异常类型不正确，则测试失败<br>另一种方式判断异常信息</p><p>with 是上下文管理器</p><p>with pytest.raises 是管理pytest抛出的异常 as 是把抛出的异常窗口命名</p><p>pytest.raises(ValueError)  括号里面的就是程序运行时的异常原因，如果等于这个异常原因，程序不会终止，会通过 ，所以在使用之前，就要知道程序运行会报什么错</p><p>然后exception_msg是接收异常窗口的值，这个可以拿去用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> pytest.raises(ValueError) <span class="hljs-keyword">as</span> excinfo: <span class="hljs-comment"># 管理窗口抛出的异常 with上下文管理器</span><br>    exception_msg = excinfo.value.args[<span class="hljs-number">0</span>] <span class="hljs-comment"># 接收窗口抛出的异常</span><br><span class="hljs-keyword">assert</span> exception_msg == <span class="hljs-string">&quot;自定义的错误信息&quot;</span> <span class="hljs-comment"># 断言</span><br></code></pre></td></tr></table></figure><blockquote></blockquote><h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><p>推导式：如果想通过操作和处理一个序列（或者其他的可迭代对象）来创建一个新的列表时</p><ul><li>列表</li><li>字典</li><li>集合</li></ul><p>列表推导式</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询验证者节点</span><br>nade_dict = self.tx.Query.query_staking_validator()  <span class="hljs-comment"># 用一个变量去接收查询出来的结果字典</span><br><span class="hljs-comment"># nade_name_list = []  # 新建空列表等下用来接收查询出来的全部node_name</span><br><span class="hljs-comment"># for i in nade_dict.get(&#x27;validators&#x27;):</span><br> <span class="hljs-comment"># nade_name_list.append(i.get(&#x27;description&#x27;).get(&#x27;moniker&#x27;)) # # 追加进这个空列表里面</span><br><br>node_name_list = [i.get(<span class="hljs-string">&#x27;description&#x27;</span>).get(<span class="hljs-string">&#x27;moniker&#x27;</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (nade_dict.get(<span class="hljs-string">&#x27;validators&#x27;</span>))]  <span class="hljs-comment"># 用推导式的写法</span><br></code></pre></td></tr></table></figure></blockquote><p>将字典内的键值对打印出来</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict = &#123;<span class="hljs-string">&#x27;k1&#x27;</span>: <span class="hljs-string">&#x27;v1&#x27;</span>, <span class="hljs-string">&#x27;k2&#x27;</span>: <span class="hljs-string">&#x27;v2&#x27;</span>, <span class="hljs-string">&#x27;k3&#x27;</span>: <span class="hljs-string">&#x27;v3&#x27;</span>&#125;<br><br><span class="hljs-comment"># 使用循环遍历字典，并打印每个键值对</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> my_dict.items():<br> <span class="hljs-built_in">print</span>(key, value)<br></code></pre></td></tr></table></figure></blockquote><p>字典组装：</p><p>zip（）函数 要学会用zip组装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">listA = [<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>]<br>listB = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>]<br><span class="hljs-comment">#把这两个列表转化成字典</span><br>dictionary = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(listA, listB))<br><br><span class="hljs-built_in">print</span>(dictionary)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">regin_node_name = &#123;<span class="hljs-string">&#x27;mevaloper1z820hara5yqa82zs8kuxjgysze3gkk6mkqe7gd&#x27;</span>: <span class="hljs-string">&#x27;node1&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1rsyss639d4aqjuuf9unjear0j6p06rjz4kgler&#x27;</span>: <span class="hljs-string">&#x27;node5&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1fd8fn2d56m3d6dwf5s7j7zgtert0rssng5u3e4&#x27;</span>: <span class="hljs-string">&#x27;node8&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1tn7vup0a6ma6x7tggkkalw6pc6x3ets9eg4ejv&#x27;</span>: <span class="hljs-string">&#x27;node4&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper10g230d2vux9je4080eggk80spn44wkg9m73nlv&#x27;</span>: <span class="hljs-string">&#x27;node6&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper10ugvk0vp8evnrtn9suaugvte8z4lcvgmgvlf62&#x27;</span>: <span class="hljs-string">&#x27;node3&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1seq5nwcscr9ugwpfyvfgc35ryk9wjpey04nkrk&#x27;</span>: <span class="hljs-string">&#x27;node7&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1kwtll6uzugd48aku78607rul5jkvvtsjaqjmcl&#x27;</span>: <span class="hljs-string">&#x27;node9&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1kl7ya94cqyzt0ppj5qtk6gxl8rqv3qctgftyfc&#x27;</span>: <span class="hljs-string">&#x27;node2&#x27;</span>&#125;<br><br>regin_list_name = &#123;<span class="hljs-string">&#x27;mevaloper1z820hara5yqa82zs8kuxjgysze3gkk6mkqe7gd&#x27;</span>: <span class="hljs-string">&#x27;CHN&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper10g230d2vux9je4080eggk80spn44wkg9m73nlv&#x27;</span>: <span class="hljs-string">&#x27;FLK&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1kwtll6uzugd48aku78607rul5jkvvtsjaqjmcl&#x27;</span>: <span class="hljs-string">&#x27;HKG&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1tn7vup0a6ma6x7tggkkalw6pc6x3ets9eg4ejv&#x27;</span>: <span class="hljs-string">&#x27;ISL&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1seq5nwcscr9ugwpfyvfgc35ryk9wjpey04nkrk&#x27;</span>: <span class="hljs-string">&#x27;LBY&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1rsyss639d4aqjuuf9unjear0j6p06rjz4kgler&#x27;</span>: <span class="hljs-string">&#x27;NFK&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper10ugvk0vp8evnrtn9suaugvte8z4lcvgmgvlf62&#x27;</span>: <span class="hljs-string">&#x27;NZL&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1fd8fn2d56m3d6dwf5s7j7zgtert0rssng5u3e4&#x27;</span>: <span class="hljs-string">&#x27;TWN&#x27;</span>,<br>                   <span class="hljs-string">&#x27;mevaloper1kl7ya94cqyzt0ppj5qtk6gxl8rqv3qctgftyfc&#x27;</span>: <span class="hljs-string">&#x27;USA&#x27;</span>&#125;<br><br><span class="hljs-comment"># new = &#123;&quot;node1&quot;: &quot;CHN&quot;, &quot;node2&quot;: &quot;USA&quot;, &quot;node3&quot;: &quot;NZL&quot;, &quot;node4&quot;: &quot;ISL&quot;, &quot;node5&quot;: &quot;NFK&quot;, &quot;node6&quot;: &quot;FLK&quot;, &quot;node7&quot;: &quot;LBY&quot;,</span><br><span class="hljs-comment">#        &quot;node8&quot;: &quot;TWN&quot;, &quot;node9&quot;: &quot;HKG&quot;&#125;</span><br><br>new = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(regin_node_name.values(), regin_list_name.values()))<br><span class="hljs-built_in">print</span>(new)<br><br>&gt;&gt;&gt;&#123;<span class="hljs-string">&quot;node1&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>, <span class="hljs-string">&quot;node2&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>, <span class="hljs-string">&quot;node3&quot;</span>: <span class="hljs-string">&quot;NZL&quot;</span>, <span class="hljs-string">&quot;node4&quot;</span>: <span class="hljs-string">&quot;ISL&quot;</span>, <span class="hljs-string">&quot;node5&quot;</span>: <span class="hljs-string">&quot;NFK&quot;</span>, <span class="hljs-string">&quot;node6&quot;</span>: <span class="hljs-string">&quot;FLK&quot;</span>, <span class="hljs-string">&quot;node7&quot;</span>: <span class="hljs-string">&quot;LBY&quot;</span>,<br>       <span class="hljs-string">&quot;node8&quot;</span>: <span class="hljs-string">&quot;TWN&quot;</span>, <span class="hljs-string">&quot;node9&quot;</span>: <span class="hljs-string">&quot;HKG&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="把两个键名相同的字典的值，组合起来组成一个新的字典。"><a href="#把两个键名相同的字典的值，组合起来组成一个新的字典。" class="headerlink" title="把两个键名相同的字典的值，组合起来组成一个新的字典。"></a>把两个键名相同的字典的值，组合起来组成一个新的字典。</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">node_dict = &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;node1&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;node3&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;node5&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-string">&quot;node2&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;node4&quot;</span>&#125;<br>region_dict = &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;CHN&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>: <span class="hljs-string">&quot;JPN&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>: <span class="hljs-string">&quot;USA&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>: <span class="hljs-string">&quot;KOR&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;RUS&quot;</span>&#125;<br><br><span class="hljs-comment"># 创建一个空字典来存储新的键值对</span><br>new_dict = &#123;&#125;<br><br><span class="hljs-comment"># 遍历node_dict中的键值对</span><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> node_dict.items():<br>    <span class="hljs-comment"># 如果键名在region_dict中也存在，则将两个值组成一个新的键值对</span><br>    <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> region_dict:<br>        new_dict[value] = region_dict[key]<br><br><span class="hljs-comment"># 输出新的字典</span><br><span class="hljs-built_in">print</span>(new_dict)<br></code></pre></td></tr></table></figure><h3 id="根据键名排序，用lamdba匿名函数"><a href="#根据键名排序，用lamdba匿名函数" class="headerlink" title="根据键名排序，用lamdba匿名函数"></a>根据键名排序，用lamdba匿名函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict_e = &#123;<span class="hljs-string">&#x27;node3&#x27;</span>: <span class="hljs-string">&#x27;ARG&#x27;</span>, <span class="hljs-string">&#x27;node9&#x27;</span>: <span class="hljs-string">&#x27;ATA&#x27;</span>, <span class="hljs-string">&#x27;node6&#x27;</span>: <span class="hljs-string">&#x27;CAN&#x27;</span>, <span class="hljs-string">&#x27;node2&#x27;</span>: <span class="hljs-string">&#x27;CHN&#x27;</span>, <span class="hljs-string">&#x27;node4&#x27;</span>: <span class="hljs-string">&#x27;HKG&#x27;</span>, <span class="hljs-string">&#x27;node12&#x27;</span>: <span class="hljs-string">&#x27;ISL&#x27;</span>, <span class="hljs-string">&#x27;node13&#x27;</span>: <span class="hljs-string">&#x27;JPN&#x27;</span>, <span class="hljs-string">&#x27;node7&#x27;</span>: <span class="hljs-string">&#x27;NZL&#x27;</span>, <span class="hljs-string">&#x27;node5&#x27;</span>: <span class="hljs-string">&#x27;RUS&#x27;</span>, <span class="hljs-string">&#x27;node11&#x27;</span>: <span class="hljs-string">&#x27;TWN&#x27;</span>, <span class="hljs-string">&#x27;node1&#x27;</span>: <span class="hljs-string">&#x27;USA&#x27;</span>, <span class="hljs-string">&#x27;node8&#x27;</span>: <span class="hljs-string">&#x27;WSM&#x27;</span>, <span class="hljs-string">&#x27;node10&#x27;</span>: <span class="hljs-string">&#x27;ZAF&#x27;</span>&#125;<br><span class="hljs-comment"># 通过node12345....排序，</span><br><span class="hljs-comment"># 思路，1 写匿名函数提取node后面的数字，</span><br>key = lamdba x : <span class="hljs-built_in">int</span>(x[<span class="hljs-number">4</span>:])  提取出来了key里面的<span class="hljs-string">&#x27;nodex&#x27;</span> node的第四位且转换成<span class="hljs-built_in">int</span>类型<br><span class="hljs-comment"># 第二步，排序，用sorted(),sorted要排序的的东西是my_dict的key，key通过lambda 切字符的第四位的数字</span><br>sorted_dict = <span class="hljs-built_in">sorted</span>(my_dict.keys(), key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x[<span class="hljs-number">4</span>:]))<br><span class="hljs-comment"># 第三步：写for循环，且转换成推导式</span><br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> sorted_dict:<br>    <span class="hljs-built_in">print</span>(k,v)<br><span class="hljs-comment"># 第四步，把for 循环，通过推导式写出来，</span><br>my_dict_sorted = &#123;k:my_dict[k] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> sorted_dict&#125;<br><br><br><span class="hljs-comment"># 最后，一行代码把所有的写出来</span><br>my_dict_sorted = &#123;k:my_dict[k] <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(my_dict.keys(),key=<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x[<span class="hljs-number">4</span>:]))&#125;<br></code></pre></td></tr></table></figure><h3 id="储存过程："><a href="#储存过程：" class="headerlink" title="储存过程："></a>储存过程：</h3><p>作用：批处理多条sql</p><p>​可以回滚，数据库函数，后端可以直接调用</p><p>一般不用，有些代码逻辑会依赖sql，</p><p>本身事务就支持多条语句，</p><p>代码可以直接用，</p><p>触发器：也不用</p><p>docker换源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/docker/daemon.json  #先看看有没有这个文件，如果没有，说明源在国外，<br>vim /etc/docker/daemon.json  # 没有就新建，复制一下镜像源到文件里就可以了<br><br>&#123;<br>    &quot;registry-mirrors&quot; : [<br>    &quot;https://registry.docker-cn.com&quot;,<br>    &quot;https://docker.mirrors.ustc.edu.cn&quot;,<br>    &quot;http://hub-mirror.c.163.com&quot;,<br>    &quot;https://cr.console.aliyun.com/&quot;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>docker 启动命令，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start $(docker ps -a | awk &#x27;&#123; print $1 &#125;&#x27; | tail -n +2 )<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps -a 展示所有容器</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">awk <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span>  设定分割点位空格，意思就是从每行开头的切片，遇到空格就把数据切成列，<span class="hljs-variable">$1</span>是取第一行第一列</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">tail</span> -n +2 不要第一组数据，从第二组开始</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker 设置网络段，注意多容器IP访问必备</span><br>dcoer network ls 查看网络段<br>docker network create mysql<br>docker net work create es<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等等</span><br><br><br></code></pre></td></tr></table></figure><h2 id="Case下的unit-做中间层"><a href="#Case下的unit-做中间层" class="headerlink" title="Case下的unit 做中间层"></a>Case下的unit 做中间层</h2><h2 id="X下的tx和query做底层"><a href="#X下的tx和query做底层" class="headerlink" title="X下的tx和query做底层"></a>X下的tx和query做底层</h2><h2 id="checklist做用例层"><a href="#checklist做用例层" class="headerlink" title="checklist做用例层"></a>checklist做用例层</h2><p>@dataclass装饰器</p><p>批量定义数据类型的</p><p><code>@dataclass</code>装饰器放在类定义的上方，这使得它成为一个数据类。</p><p>字典取值，方括号可点get的区别，</p><ul><li>如果被取字典里面没有这个键，。那么方括号会抛出程序错误KeyError</li><li>如果用点get，则会返回None，不会报错</li></ul><h2 id="pycharm调试断点，"><a href="#pycharm调试断点，" class="headerlink" title="pycharm调试断点，"></a>pycharm调试断点，</h2><p>在可能错误的那一行的前面打上断点，在这一行的下一步的地方也打上断点，如果没进入怀疑错误的下一行，就跳出来了，就说明确定是怀疑错了的这一行，</p><p>再在这一行的对象上面查看对象的内容属性参数啥的</p><p><img src="/img/image-20230614103341677.png" alt="image-20230614103341677"></p><p>关于pycharm的调试时，在对应的函数内的某一个步骤上设置好断点，开启debug调试，在即将走到你怀疑的步骤上时，你可以打开这个输入对应的对象，查看这个对象内部和下面的对象以及输入对应的方法后的返回值是否符合你的要求</p><h1 id="classmethod和staticmethod装饰器"><a href="#classmethod和staticmethod装饰器" class="headerlink" title="classmethod和staticmethod装饰器"></a>classmethod和staticmethod装饰器</h1><p>@staticmethod的意思就是将后面的函数转化成静态函数，</p><p>大多数情况下，@classmethod和@staticmethod的效果是一样的，</p><p>正式作用是类工厂，如果有类继承关系，更加明显，</p><h2 id="staticmethod装饰器-（直译：静态方法）"><a href="#staticmethod装饰器-（直译：静态方法）" class="headerlink" title="staticmethod装饰器 （直译：静态方法）"></a>staticmethod装饰器 （直译：静态方法）</h2><p>函数静态化，加了这个装饰器后，这个函数就不需要所在的类实例化后调用，可以直接类名点方法调用</p><p>静态装饰器，如果类内的这个方法 ，没有用到类的属性和方法，。就可以用类装饰器，</p><p>这个方法没有用到类的属性和方法，是独立于这个类之外的方法，</p><p>可以不用通过实例化去调用这个方法，可以直接调用这个方法。</p><p>可以把一堆用不到类属性和类方法的方法放在一个类中，然后用staticmethod装饰起来。；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dates</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, date</span>):<br>        self.date = date<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getDate</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.date<br> <br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toDashDate</span>(<span class="hljs-params">date</span>):<br>        <span class="hljs-keyword">return</span> date.replace(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>)<br> <br>date = Dates(<span class="hljs-string">&quot;15-12-2016&quot;</span>)<br>dateFromDB = <span class="hljs-string">&quot;15/12/2016&quot;</span><br>dateWithDash = Dates.toDashDate(dateFromDB)<br> <br><span class="hljs-keyword">if</span>(date.getDate() == dateWithDash):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Equal&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Unequal&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="classmethod装饰器-（直译：类方法）"><a href="#classmethod装饰器-（直译：类方法）" class="headerlink" title="classmethod装饰器 （直译：类方法）"></a>classmethod装饰器 （直译：类方法）</h1><ol><li>无需实例生成</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    bar = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;foo!&quot;</span>)<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;funce2&quot;</span>)<br>        <span class="hljs-built_in">print</span>(cls.bar)<br>        cls().fun1() <span class="hljs-comment"># 可直接调用foo方法</span><br>A.func2()  <span class="hljs-comment"># 不需要实例化</span><br></code></pre></td></tr></table></figure><ol start="2"><li>@classmethod类工厂 可以直接实例类内对应的方法</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date<br> <br><span class="hljs-comment"># random Person</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br> <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fromBirthYear</span>(<span class="hljs-params">cls, name, birthYear</span>):<br>        <span class="hljs-keyword">return</span> cls(name, date.today().year - birthYear)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.name + <span class="hljs-string">&quot;&#x27;s age is: &quot;</span> + <span class="hljs-built_in">str</span>(self.age))<br> <br>person = Person(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">19</span>)<br>person.display()<br> <br>person1 = Person.fromBirthYear(<span class="hljs-string">&#x27;John&#x27;</span>,  <span class="hljs-number">1985</span>)<br>person1.display()<br></code></pre></td></tr></table></figure><h2 id="classmethod和-staticmethod的区别"><a href="#classmethod和-staticmethod的区别" class="headerlink" title="@classmethod和@staticmethod的区别"></a>@classmethod和@staticmethod的区别</h2><p>假设创建Foo的子类并且在子类上调用了create_new方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>(<span class="hljs-title class_ inherited__">Foo</span>):<br>    <span class="hljs-keyword">pass</span><br>obj = Bar.create_new()<br></code></pre></td></tr></table></figure><p>然后这个基类将导致一个新的Bar对象被创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_new</span>:<br>        <span class="hljs-keyword">return</span> cls()<br></code></pre></td></tr></table></figure><p>而这个基类会导致创建一个新的Foo对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span>:<br><span class="hljs-meta">    @staticemethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_new</span>():<br>        <span class="hljs-keyword">return</span> Foo()<br></code></pre></td></tr></table></figure><p>怎么用，用哪一个，取决于你想要什么行为</p><h2 id="字符串转字典"><a href="#字符串转字典" class="headerlink" title="字符串转字典"></a>字符串转字典</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 终端输出output 内容为：标题：&#123;&#125;这样的模式，我们要取标题： 后面的内容。</span><br><span class="hljs-comment"># 思路：切片索引，找到索引头，找到被查找内容占索引总长度，</span><br><span class="hljs-comment"># out.find(&quot;被查内容&quot;) 这一步是找到&quot;被查内容&quot;的起始索引</span><br><span class="hljs-comment"># len(&quot;被查内容&quot;) 确定被查内容的长度，</span><br><span class="hljs-comment"># 起始索引+索引内容长度等于被查找的output 的查找起始索引，</span><br>output = <span class="hljs-string">&#x27;unsign tx is: &#123;&quot;body&quot;:&#123;&quot;messages&quot;:[&#123;&quot;@type&quot;:&quot;/cosmos.bank.v1beta1.MsgSend&quot;,&quot;from_address&quot;:&quot;me1xdflnur4d0gt25r4mazurfkath34emaxsda5vm&quot;,&quot;to_address&quot;:&quot;me1da7lnew869eh6z0mtfp363d7lccvczkduzqg9a&quot;,&quot;amount&quot;:[&#123;&quot;denom&quot;:&quot;umec&quot;,&quot;amount&quot;:&quot;100&quot;&#125;]&#125;],&quot;memo&quot;:&quot;&quot;,&quot;timeout_height&quot;:&quot;0&quot;,&quot;extension_options&quot;:[],&quot;non_critical_extension_options&quot;:[]&#125;,&quot;auth_info&quot;:&#123;&quot;signer_infos&quot;:[],&quot;fee&quot;:&#123;&quot;amount&quot;:[&#123;&quot;denom&quot;:&quot;umec&quot;,&quot;amount&quot;:&quot;100&quot;&#125;],&quot;gas_limit&quot;:&quot;200000&quot;,&quot;payer&quot;:&quot;&quot;,&quot;granter&quot;:&quot;&quot;&#125;,&quot;tip&quot;:null&#125;,&quot;signatures&quot;:[]&#125;&#x27;</span><br><br>start_index = output.find(<span class="hljs-string">&#x27;unsign tx is: &#x27;</span>) + <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;unsign tx is: &#x27;</span>)<br><span class="hljs-comment"># out.find(&quot;被查内容&quot;) 这一步是找到&quot;被查内容&quot;的起始索引</span><br>extracted_content = output[start_index:] <span class="hljs-comment"># output[开始索引：结束索引]结束索引是空说明一直切片到最后</span><br><br><span class="hljs-built_in">print</span>(extracted_content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是一个标题</title>
    <link href="/2023/12/25/first/"/>
    <url>/2023/12/25/first/</url>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul><li>第一个</li><li>第二个</li><li>测试一下</li><li>测测测猜测测测猜测</li><li>test write blog hhh</li><li>test home write</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标签1</tag>
      
      <tag>标签2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【python】httprunner接口自动化框架</title>
    <link href="/2023/12/24/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/"/>
    <url>/2023/12/24/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="httprunner接口自动化框架"><a href="#httprunner接口自动化框架" class="headerlink" title="httprunner接口自动化框架"></a>httprunner接口自动化框架</h1><h1 id="一、为什么选择httprunner？"><a href="#一、为什么选择httprunner？" class="headerlink" title="一、为什么选择httprunner？"></a>一、为什么选择httprunner？</h1><ul><li>HttpRunner是一个开源的 API 测试工具环境搭建，相比于其它 API 测试工具，HttpRunner 最大的不同在于设计理念：</li><li>约定大于配置：测试用例是标准结构化的，格式统一，方便协作和维护；</li><li>标准开放：基于开放的标准，支持HAR&#x2F;Postman&#x2F;Swagger等工具对接，轻松实现用例生成和转换；</li><li>一次投入多维复用：一套脚本可同时支持接口自动化测试、性能测试；</li><li>追求不重复造轮子，追求投入产出比；</li><li>Httprunner和其他开源框架相比，我们只需在yaml文件维护测试用例即可，不需要代码要求，但是需要严格遵循yanl格式编写，否则在后续不好排查错误，这也是httprunner的一个缺点；</li><li>目前市面上接口工具多，学习成本高，团队协作较困难，对语言能力有一定要求，门槛较高；</li></ul><h1 id="二、环境搭建（Python安装）"><a href="#二、环境搭建（Python安装）" class="headerlink" title="二、环境搭建（Python安装）"></a>二、环境搭建（Python安装）</h1><h2 id="1、python版本：2-7-3-7及以上版本，建议3-7及以上版本"><a href="#1、python版本：2-7-3-7及以上版本，建议3-7及以上版本" class="headerlink" title="1、python版本：2.7&#x2F;3.7及以上版本，建议3.7及以上版本"></a>1、python版本：2.7&#x2F;3.7及以上版本，建议3.7及以上版本</h2><ul><li>下载地址：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li></ul><h2 id="2、验证安装是否成功"><a href="#2、验证安装是否成功" class="headerlink" title="2、验证安装是否成功"></a>2、验证安装是否成功</h2><ul><li>打开cmd命令行 输入python，如果能进入python命令模式就证明成功了</li><li></li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled.png" alt="Untitled"></p><h2 id="3、安装httprunner第三方库"><a href="#3、安装httprunner第三方库" class="headerlink" title="3、安装httprunner第三方库"></a>3、安装httprunner第三方库</h2><p>pip install httprunner&#x3D;&#x3D;2.5.7 如果官网无法下载就加国内镜像 -i <a href="https://pypi.doubanio.com/simple">https://pypi.doubanio.com/simple</a></p><h2 id="4、查看命令行指令（掌握几个常用即可）"><a href="#4、查看命令行指令（掌握几个常用即可）" class="headerlink" title="4、查看命令行指令（掌握几个常用即可）"></a>4、查看命令行指令（掌握几个常用即可）</h2><ul><li>创建一个项目，可以在命令行查看httprunner帮助</li><li>httprunner -h 或者 hrun -h</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%201.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%202.png" alt="Untitled"></p><h2 id="5、创建脚手架"><a href="#5、创建脚手架" class="headerlink" title="5、创建脚手架"></a>5、创建脚手架</h2><ul><li>创建项目：hrun –startproject demo</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%203.png" alt="Untitled"></p><h2 id="6、安装第三方依赖（）"><a href="#6、安装第三方依赖（）" class="headerlink" title="6、安装第三方依赖（）"></a>6、安装第三方依赖（）</h2><ul><li>可以在根目录下建个requirements.txt文件，需要安装的python依赖都在这个文件里面，进入到目录下，执行以下命令进行安装：</li></ul><p>pip install –r requirements2.txt</p><h1 id="三、框架结构"><a href="#三、框架结构" class="headerlink" title="三、框架结构"></a>三、框架结构</h1><h2 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h2><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%204.png" alt="Untitled"></p><h3 id="分层思想："><a href="#分层思想：" class="headerlink" title="分层思想："></a>分层思想：</h3><ul><li>api定义层：最底下的一层是api的定义层，最底</li><li>testcase层：测试用例层，调用定义层的内容，中间</li><li>testsuite：测试套件层，把用例装起来，最上</li><li></li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%205.png" alt="Untitled"></p><h3 id="api目录：存放描述api信息的yaml文件"><a href="#api目录：存放描述api信息的yaml文件" class="headerlink" title="api目录：存放描述api信息的yaml文件"></a>api目录：存放描述api信息的yaml文件</h3><ul><li>特别注意：yml文件需遵循严格的缩进，缩进多少格无所谓，只要保证同一层级的key对齐即可</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%206.png" alt="Untitled"></p><h3 id="字段解释："><a href="#字段解释：" class="headerlink" title="字段解释："></a>字段解释：</h3><ul><li>name：对api进行描述</li><li>variables：把参数作为变量从外部传给api，可以将变量的参数都定义在variables</li><li>request：这个字段下放的都是api的基本信息如<ul><li>url(请求地址)，</li><li>method(请求方法)，</li><li>headers(请求头)，</li><li>data&#x2F;params&#x2F;json&#x2F;file (请求参数)</li></ul></li></ul><h3 id="一般接口有3种方式的请求参数"><a href="#一般接口有3种方式的请求参数" class="headerlink" title="一般接口有3种方式的请求参数"></a>一般接口有3种方式的请求参数</h3><ul><li>1.params字段传参：<ul><li>以key，value键值对方式放在url后面的参数用params字段去定义</li></ul></li><li>2.json字段传参：<ul><li>放在body以json格式参数的用json字段去定义</li></ul></li><li>3.c.data字段传参：<ul><li>放在body非json格式的参数用data字段去定义，如headers中</li></ul></li></ul><p>content-type&#x3D;application&#x2F;x-www-form-urlencoded</p><h3 id="参数引用：引用符："><a href="#参数引用：引用符：" class="headerlink" title="参数引用：引用符：$"></a>参数引用：引用符：$</h3><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%207.png" alt="Untitled"></p><ul><li>variables：api的ymal文件下：如果我们要把参数作为变量从外部传给api，那就把作为变量的参数都定义在variables字段下，如下图中的loginPara就可以被其它任何地方引用。</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%208.png" alt="Untitled"></p><ul><li>validate：校验字段，需要校验的数据都写在这个字段下</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%209.png" alt="Untitled"></p><h3 id="1-2-testcases目录：存放描述测试用例的yaml文件"><a href="#1-2-testcases目录：存放描述测试用例的yaml文件" class="headerlink" title="1.2 testcases目录：存放描述测试用例的yaml文件"></a>1.2 testcases目录：存放描述测试用例的yaml文件</h3><ul><li>config:指这条用例的配置信息，用例的一些配置信息可以写在这个字段下面，比如：<ul><li>name(必须的)：　这条用例的名字，</li><li>base_url(可选择的)： 接口的host地址，一般写域名</li><li>variables(可选择的)： 这条用例的一些变量，保存的变量，可以被下面引用</li><li>verify(可选，但默认false)：指定是否验证服务器的TLS证书。如果想要记录testcase中的http数据特别有用。如果不设置或者设置为true则会产生SSLError错误。</li><li>export(可选择的，必须会)：提取testcase的session变量。测试用例是为黑盒，config中的的variables视为输入，export为输出。特别是，当该testcase中的某个输出作为下一个testcase中的输入的时候特别有用。参数传递用的，</li><li>output(可选择的)：为了把变量暴露出来，打印日志时看的更清楚（比如说你提取了token,可以打印一下这个token看看自己有没有提取成功）</li></ul></li></ul><h3 id="teststeps-：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如："><a href="#teststeps-：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如：" class="headerlink" title="teststeps:：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如："></a>teststeps:：指用例中的步骤，每一步就是调用一个api，test下面配置的字段就是这个步骤中涉及的字段，比如：</h3><ul><li><p>name：步骤描述</p></li><li><p>api： 指定调用的api路径文件。基于根目录的相对路径</p></li><li><p>testcase： 指定testcase的路径文件</p></li><li><p>extract： 提取响应中的字段（比如这个接口返回中的某个字段作为下一个接口的参数），可以提取的内容包含以下内容：</p><ul><li>atus_code、cookies、elapsed（响应时间）、headers、content、 text、json、encoding、ok、 reason、url</li></ul></li><li><p>variables：如果要把参数作为变量从外部传给api，那就把作为变量的 参数都定义在variables字段下，设置变量供下面用</p><ul><li><h2 id="引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，-先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：-参数引用-ENV-STATIONNAME-的时候，要在variables下面先定义再引用"><a href="#引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，-先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：-参数引用-ENV-STATIONNAME-的时候，要在variables下面先定义再引用" class="headerlink" title="引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，  - 先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：  - 参数引用${ENV(STATIONNAME)的时候，要在variables下面先定义再引用"></a>引用debugtalk里面的数据库查询方法时，要在这里定义一个字段，<br>  - 先把sql语句定义成一个字段，然后把sql语句引用到方法里面去，如下：<br>  - <code>参数引用$&#123;ENV(STATIONNAME)的时候，要在variables下面先定义再引用</code></h2>  <img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2010.png" alt="Untitled"></li></ul></li><li><p>validate：校验字段，需要校验的数据都写在这个字段下，就是断言，下面会讲断言用法</p></li><li><p>⑦　碰到列表的时候，用list.0去提取。点0是表示提取索引下标为0的列表进行提取</p><ul><li><code>- eq: [ json.data.list.0.couponName, &quot;自动化测试兑换&quot; ]</code></li></ul></li></ul><h2 id="testsuites目录：存放用例集的yaml文件"><a href="#testsuites目录：存放用例集的yaml文件" class="headerlink" title="testsuites目录：存放用例集的yaml文件"></a>testsuites目录：存放用例集的yaml文件</h2><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2011.png" alt="Untitled"></p><h3 id="字段解释：-1"><a href="#字段解释：-1" class="headerlink" title="字段解释："></a>字段解释：</h3><ol><li>testcases：指这条用例集，要执行的用例都现在这个字段下面</li><li>testcase：用例的路径字段</li><li>parameters：参数化字段，外部传的参给用例，都可以写在这个字段下面，测试数据中的参数可以写在这下面</li></ol><h3 id="用例编写"><a href="#用例编写" class="headerlink" title="用例编写"></a>用例编写</h3><ul><li>参数引用：在yaml文件中用“$”符号实现对参数的引用 比如:</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2012.png" alt="Untitled"></p><ul><li>2.2函数引用：在yaml文件中通过“${}”实现对函数的引用，比如：</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2013.png" alt="Untitled"></p><ul><li>所有函数都定义在debugtalk.py文件中，</li><li>如果在测试中有需要写代码处理的，就可以把代码写在debugtalk.py文件中，然后用例中就可以直接引用了。</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2014.png" alt="Untitled"></p><h1 id="运行接口"><a href="#运行接口" class="headerlink" title="运行接口"></a>运行接口</h1><h2 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h2><ul><li>使用命令行调试：hrun .\testsuites\xx测试集.yml</li><li>如果要打印运行详细日志，在命令后面加上–log-level</li></ul><p>hrun .\testsuites\xx测试集.yml –log-level debug</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2015.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2016.png" alt="Untitled"></p><h2 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h2><ul><li>在工程跟目录下有一个runtest.py文件，里面指定要执行的文件路径就可以运用用例了，右键——Run rentest 就可以执行，执行后会在report目录下生成测试报告</li><li>通过<code>os.system</code>可以调用cmd命令，方便自己调试用。</li><li>注意一下，cmd命令的斜杠是反斜杠，注意斜杠加t需要双斜杠，不然会编译错误</li><li></li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2017.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2018.png" alt="Untitled"></p><h1 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h1><p>报告保存在report目录下，每次执行完都会生成测试报告，用浏览器即可打开进行查看</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2019.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2020.png" alt="Untitled"></p><h2 id="一些特殊接口—图片上传接口"><a href="#一些特殊接口—图片上传接口" class="headerlink" title="一些特殊接口—图片上传接口"></a>一些特殊接口—图片上传接口</h2><p>用抓包软件看到接口传参如图所示</p><p>注意：requests库会自动添加这个元素 {“Content-Type”:”multipart&#x2F;form-data”} ；加了反而会报错，从而导致请求不成功。</p><p>在前端允许和支持上传的所有格式文件中，当选择不同格式文件时对接口发起请求时，</p><p>Form Data会自动识别文件的Content-Type【根据传入的文件格式自动解析为headers中的Content-Type】以及Content-Disposition【该字段中包括接口的传参类型（例如下图的form-data），传入文件名（例如下图的filename）等】。</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2021.png" alt="Untitled"></p><p>所以参数我们可以如图中files字段那样定义</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2022.png" alt="Untitled"></p><h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2023.png" alt="Untitled"></p><p>data目录下就是存放测试数据文件，我们需要上传文件或图片的数据可以放在这个目录下，或api中的一些参数数据可以以csv文件格式存放在这个目录下</p><h1 id="参数化："><a href="#参数化：" class="headerlink" title="参数化："></a>参数化：</h1><h2 id="对测试数据的引用"><a href="#对测试数据的引用" class="headerlink" title="对测试数据的引用"></a>对测试数据的引用</h2><ul><li>在用例中怎么使用测试数据文件中的数据呢，</li><li>框架中有个读取数据文件的函数P，</li><li>引用时参入数据文件地址作为参数 ${P(data&#x2F;对应的csv.csv)} 对应的csv.csv 文件内容如图，</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2024.png" alt="Untitled"></p><ul><li>注意：只能在testsuite中对测试数据的引用，测试数据中的参数可以 字段名-字段名的方式进行获取。qudaologin.csv中有几条记录，这样用例就会执行几次</li><li>再说一遍，只能在testsuite里面引用csv参数，<ul><li>在testcase的下面加一个字段parameters：下面再接需要被传参的字段名</li><li>csv的参数有多少行，对应的用例就会被执行多少次</li></ul></li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2025.png" alt="Untitled"></p><h2 id="直接赋值参数"><a href="#直接赋值参数" class="headerlink" title="直接赋值参数"></a>直接赋值参数</h2><ul><li>多个关联参数，可以按照下图中的方式对用例参数进行赋值，进行该配置后，测试用例在运行时就会对 name，result实现数据驱动，即分别运行 3次测试，并且保证参数值总是成对使用。</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2026.png" alt="Untitled"></p><h2 id="单个参数关联"><a href="#单个参数关联" class="headerlink" title="单个参数关联"></a>单个参数关联</h2><ul><li>单个参数可以直接就可以按照如下方式进行配置，即分别使用 [1,2,3,4,5,6,7] 7个值运行测试用例。</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2027.png" alt="Untitled"></p><h1 id="环境变量："><a href="#环境变量：" class="headerlink" title="环境变量："></a>环境变量：</h1><ul><li>工程目录下有个.env文件，里面可以配置测试环境的地址，如图所示</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2028.png" alt="Untitled"></p><ul><li>框架有个获取环境文件的函数ENV, 调用时可以引用函数获取变量${ENV(TESTENV)}</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2029.png" alt="Untitled"></p><h1 id="9-断言校验"><a href="#9-断言校验" class="headerlink" title="9. 断言校验"></a>9. 断言校验</h1><h2 id="框架中已实现如下校验"><a href="#框架中已实现如下校验" class="headerlink" title="框架中已实现如下校验"></a>框架中已实现如下校验</h2><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2030.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2031.png" alt="Untitled"></p><h2 id="9-2自定义校验函数"><a href="#9-2自定义校验函数" class="headerlink" title="9.2自定义校验函数"></a>9.2自定义校验函数</h2><p>对于自定义的校验函数，需要遵循三个规则：</p><ol><li>自定义校验函数需放置到debugtalk.py中</li><li>参数有两个：第一个为原始数据，第二个为原始数据经过运算后得到的预期结果值</li><li>在校验函数中通过assert将实际运算结果与预期结果值进行比较</li></ol><p>如图：在debugtalk.py文件中定义校验函数</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2032.png" alt="Untitled"></p><p>然后在用例校验的时候引用这个校验函数</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2033.png" alt="Untitled"></p><h2 id="9-3修改框架校验函数：不建议"><a href="#9-3修改框架校验函数：不建议" class="headerlink" title="9.3修改框架校验函数：不建议"></a>9.3修改框架校验函数：不建议</h2><ul><li>在httprunner&gt;builtin&gt;comparator新增自定义校验，然后在parser文件中定义校验缩写方法</li></ul><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2034.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2035.png" alt="Untitled"></p><h2 id="9-4校验支持正则校验："><a href="#9-4校验支持正则校验：" class="headerlink" title="9.4校验支持正则校验："></a>9.4校验支持正则校验：</h2><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2036.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2037.png" alt="Untitled"></p><h2 id="9-5数据库校验："><a href="#9-5数据库校验：" class="headerlink" title="9.5数据库校验："></a>9.5数据库校验：</h2><p>框架实现了对数据库的查询，操作数据库的原理是根据输入的SQL语句 过滤出要操作的tableName, 然后去配置文件中找到对应得tableName所在的地址和库进行连接和操作，操作数据库需要做如下配置，在跟目录下有个database.ini文件，在里面配置数据库相关信息</p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2038.png" alt="Untitled"></p><p><img src="/httprunner%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%2021144adb494f46bf8f80869a1d089171/Untitled%2039.png" alt="Untitled"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>部署</tag>
      
      <tag>接口自动化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【other】WSL基础使用指南</title>
    <link href="/2023/12/23/WSL%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/12/23/WSL%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="WSL使用指南"><a href="#WSL使用指南" class="headerlink" title="WSL使用指南"></a>WSL使用指南</h1><h1 id="1、WSL介绍和安装"><a href="#1、WSL介绍和安装" class="headerlink" title="1、WSL介绍和安装"></a>1、WSL介绍和安装</h1><h4 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h4><ul><li>Windows Subsystem for Linux（简称WSL）是一个在Windows 10\11上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，其目标是使纯正的Ubuntu、Debian等映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</li><li><strong>优势</strong>：开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能。 通过适用于 Linux 的 Windows 子系统 (WSL)，开发人员可以安装 Linux 发行版（例如 Ubuntu、OpenSUSE、Kali、Debian、Arch Linux 等），并直接在 Windows 上使用 Linux 应用程序、实用程序和 Bash 命令行工具，不用进行任何修改，也无需承担传统虚拟机或双启动设置的费用。</li><li>一句话，<strong>在windows上不需要通过虚拟机运行Linux</strong> ，</li></ul><h4 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h4><p>先开启Windows对子系统的支持：<strong>控制面板–&gt;程序–&gt;启用或关闭Windows功能</strong></p><ul><li>打开Hyper-V</li><li>打开适用于Linux的Windows子系统</li></ul><h4 id="三、安装WSL"><a href="#三、安装WSL" class="headerlink" title="三、安装WSL"></a>三、安装WSL</h4><h5 id="1-启用适用于-Linux-的-Windows-子系统"><a href="#1-启用适用于-Linux-的-Windows-子系统" class="headerlink" title="1 启用适用于 Linux 的 Windows 子系统"></a>1 启用适用于 Linux 的 Windows 子系统</h5><p>需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。</p><p>以管理员身份打开 PowerShell（“开始”菜单 &gt;“PowerShell” &gt;单击右键 &gt;“以管理员身份运行”），然后输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart<br></code></pre></td></tr></table></figure><h5 id="2-启用虚拟机功能"><a href="#2-启用虚拟机功能" class="headerlink" title="2 启用虚拟机功能"></a>2 启用虚拟机功能</h5><p>安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。</p><p>以管理员身份打开 PowerShell 并运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart<br></code></pre></td></tr></table></figure><p><strong>重新启动计算机，以完成 WSL 安装并更新到 WSL 2。</strong></p><p>安装完重启后在PowerShell中设置默认为WSL2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl --set-default-version 2<br></code></pre></td></tr></table></figure><h5 id="3-安装所选的-Linux-分发"><a href="#3-安装所选的-Linux-分发" class="headerlink" title="3  安装所选的 Linux 分发"></a>3  安装所选的 Linux 分发</h5><p>在MicroSoft Store中搜索并下载想要使用的linux版本，我这里使用的ubuntu 20版本（或22版本）</p><p><strong>4  运行WSL</strong></p><p>终端使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl -h # 查看命令help<br>wsl # 运行wsl<br></code></pre></td></tr></table></figure><h1 id="2、进入WSL-安装开启ssh远程"><a href="#2、进入WSL-安装开启ssh远程" class="headerlink" title="2、进入WSL 安装开启ssh远程"></a>2、进入WSL 安装开启ssh远程</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo passwd root   #设置root账号密码。根据提示输入root密码即可。<br>12345678<br>su User  #切换账号. root账号是 # 结尾，非root账号是 $结尾<br><br>// 更新环境<br>sudo apt-get update<br><br>ifconfig # 如果没有就执行下面的<br>sudo apt-get install net-tools<br><br>// 安装ssh<br>sudo apt-get install openssh-server<br><br>sudo apt-get install openssh-server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编辑sshd_config文件</span><br>vim /etc/ssh/sshd_config<br><br>Port 2222   #设置ssh的端口号, 由于22在windows中有别的用处, 尽量不修改系统的端口号<br>PermitRootLogin yes   # 可以root远程登录<br>PasswordAuthentication yes     # 密码验证登录<br><span class="hljs-meta prompt_">#</span><span class="language-bash">设置SSH的端口号,尽量避免与Windows端口号冲突</span><br>Port 2345<br><span class="hljs-meta prompt_">#</span><span class="language-bash">允许远程登录</span><br>PermitRootLogin yes   <br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用密码登录</span><br>PasswordAuthentication yes<br><span class="hljs-meta prompt_">#</span><span class="language-bash">SSH登录时的用户名字</span><br>AllowUsers wsl_username<br><br>安装ssh<br>apt-get install ssh<br><br>开启 ssh<br>/etc/init.d/ssh start<br><br>出现* Starting OpenBSD Secure Shell server sshd报错就<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -A</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">/etc/init.d/ssh start</span><br>可以远程连接了<br>sudo ps -e | grep ssh # 输入查看有没有启动成功<br>如果显示对应的端口号，就说明启动成功了<br><br></code></pre></td></tr></table></figure><h1 id="3、更新服务器软件源（阿里云源）并更新软件"><a href="#3、更新服务器软件源（阿里云源）并更新软件" class="headerlink" title="3、更新服务器软件源（阿里云源）并更新软件"></a><strong>3、更新服务器软件源（阿里云源）并更新软件</strong></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 root 权限登录，后续输入密码</span><br>sudo -i<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接下来备份当前源，输入以下命令</span><br>cp /etc/apt/sources.list /etc/apt/sources.list.old <br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这个sources.list文件就是源文件，删除该文件，重新写一个</span><br>rm /etc/apt/sources.list<br>vim /etc/apt/sources.list<br><br></code></pre></td></tr></table></figure><h2 id="更新软件源（阿里云源）并更新软件"><a href="#更新软件源（阿里云源）并更新软件" class="headerlink" title="更新软件源（阿里云源）并更新软件"></a><strong>更新软件源（阿里云源）并更新软件</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 root 权限登录，后续输入密码</span><br>sudo -i<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">接下来备份当前源，输入以下命令</span><br>cp /etc/apt/sources.list /etc/apt/sources.list.old <br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这个sources.list文件就是源文件，删除该文件，重新写一个</span><br>rm /etc/apt/sources.list<br>vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>复制下面内容，然后单击右键粘贴进去即可，之后按ESC，输入wq保存并退出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell">deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.aliyun.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br> <br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse<br>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br> <br>deb http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse<br>deb http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># Pre-released source, not recommended.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">deb-src http://mirrors.163.com/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开始更新软件镜像源和软件包</span><br>sudo apt update      <span class="hljs-comment">#更新软件源</span><br>sudo apt upgrade     <span class="hljs-comment">#更新软件包</span><br></code></pre></td></tr></table></figure><h1 id="4、docker-安装"><a href="#4、docker-安装" class="headerlink" title="4、docker 安装"></a>4、docker 安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">1. 先卸载旧版本的docke<br>sudo apt-get remove docker docker-engine docker.io<br>2. 更新一下apt-get源<br>sudo apt-get update<br>3. 安装GPG证书<br><span class="hljs-meta prompt_">#</span><span class="language-bash">别忘了最后的“-”</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>4. 写入软件源信息<br>sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;<br>5. 列出可用版本<br>sudo apt-cache madison docker-ce<br>6. 更新并安装 Docker-CE<br>sudo apt-get update<br>sudo apt-get install docker-ce=5:23.0.5-1~ubuntu.20.04~focal<br>sudo apt-get install docker-ce=5:24.0.4-1~ubuntu.22.04~jammy<br>7. 开启docker服务，查看docker状态<br>sudo service docker start<br>sudo service docker status<br>systemctl restart docker<br>8.使用docker的命令，查看现有镜像和正在运行的容器<br>docker images<br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker compose安装</span><br>curl -L &quot;https://github.com/docker/compose/releases/download/1.29.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -<br>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;<br><br>sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h3 id="docker-换源"><a href="#docker-换源" class="headerlink" title="docker 换源"></a>docker 换源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost henryhzy]# vim /etc/docker/daemon.json  # 创建或修改 /etc/docker/daemon.json 文件，修改为如下形式<br>&#123;<br>    &quot;registry-mirrors&quot; : [<br>    &quot;https://docker.mirrors.ustc.edu.cn&quot;,<br>    &quot;http://hub-mirror.c.163.com&quot;,<br>    &quot;https://cr.console.aliyun.com/&quot;<br>  ]<br>&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl daemon-reload</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl restart docker</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker info</span><br></code></pre></td></tr></table></figure><h1 id="5、docker搭建个人博客"><a href="#5、docker搭建个人博客" class="headerlink" title="5、docker搭建个人博客"></a>5、docker搭建个人博客</h1><h3 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">先输入命令安装docker-compose<br>sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<br>sudo chmod +x /usr/local/bin/docker-compose<br>sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose<br><br>测试已下版本<br>docker-compose --version<br>显示docker-compose version 1.26.0, build d4451659<br><br>再拉两个镜像<br>docker pull wordpress<br><br>docker pull mysql:5.6<br><br>建一个文件夹放wordpress bolg<br>mkdir -p /wang/wordpress<br></code></pre></td></tr></table></figure><h3 id="vi命令-创建一个docker-compose-yml"><a href="#vi命令-创建一个docker-compose-yml" class="headerlink" title="vi命令 创建一个docker-compose.yml"></a>vi命令 创建一个docker-compose.yml</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim docker-compose.yml<br></code></pre></td></tr></table></figure><h3 id="把下文内容写进docker-compose-yml里面"><a href="#把下文内容写进docker-compose-yml里面" class="headerlink" title="把下文内容写进docker-compose.yml里面"></a>把下文内容写进docker-compose.yml里面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell">version: &#x27;3&#x27;<br>services:<br>  wordpress:<br>    image: wordpress<br>    restart: always<br>    ports:<br>      - 80:9090<br>    environment:<br>      WORDPRESS_DB_HOST: db<br>      WORDPRESS_DB_USER: exampleuser<br>      WORDPRESS_DB_PASSWORD: examplepass<br>      WORDPRESS_DB_NAME: exampledb<br>    networks:<br>      - wang-net<br>    volumes:<br>      - wordpress:/var/www/html<br><br>  db:<br>    image: mysql:5.6<br>    restart: always<br>    environment:<br>      MYSQL_DATABASE: exampledb<br>      MYSQL_USER: exampleuser<br>      MYSQL_PASSWORD: examplepass<br>      MYSQL_RANDOM_ROOT_PASSWORD: &#x27;1&#x27;<br>    volumes:<br>      - db:/var/lib/mysql<br>    networks:<br>      - wang-net<br><br>volumes:<br>  wordpress:<br>  db:<br>  <br>networks:<br>  wang-net:<br>    driver: bridge<br></code></pre></td></tr></table></figure><h3 id="再执行命令启动这个compose"><a href="#再执行命令启动这个compose" class="headerlink" title="再执行命令启动这个compose"></a>再执行命令启动这个compose</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><h1 id="6、docker配置数据库"><a href="#6、docker配置数据库" class="headerlink" title="6、docker配置数据库"></a>6、docker配置数据库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>wsl</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>djangoAdmin部署记录</title>
    <link href="/2023/12/15/djangoAdmin%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/12/15/djangoAdmin%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="部署笔记"><a href="#部署笔记" class="headerlink" title="部署笔记"></a>部署笔记</h1><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><blockquote><p>Python &gt;&#x3D; 3.8.0 (推荐3.9+版本)<br>nodejs &gt;&#x3D; 14.0 (推荐最新)<br>Mysql &gt;&#x3D; 5.7.0 (可选，默认数据库sqlite3，推荐8.0版本)<br>Redis(可选，最新版)</p></blockquote><h2 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h2><h3 id="拉代码部署"><a href="#拉代码部署" class="headerlink" title="拉代码部署"></a>拉代码部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉代码</span><br>进入后端项目目录:cd backend<br>在项目根目录中，复制 ./conf/env.example.py 文件为一份新的到 ./conf/env.py 下，并重命名为env.py<br>在 env.py 中配置数据库信息(默认数据库为sqlite3，测试演示可忽略此步骤)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker 部署mysql</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker创建数据库 DATABASE_NAME = <span class="hljs-string">&#x27;django-vue-admin&#x27;</span> <span class="hljs-comment"># mysql 时使</span></span><br>安装依赖环境: pip3 install -r requirements.txt<br>如果有碰到mysqlclient 无法安装的时候，查一下手册，mac是要brew install mysql <br>执行迁移命令: python3 manage.py makemigrations python3 manage.py migrate<br>初始化数据: python3 manage.py init<br>初始化省市县数据: python3 manage.py init_area<br>启动项目: python3 manage.py runserver 0.0.0.0:8000<br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker 部署mysql</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker创建数据库 DATABASE_NAME = <span class="hljs-string">&#x27;django-vue-admin&#x27;</span> <span class="hljs-comment"># mysql 时使用</span></span><br><br></code></pre></td></tr></table></figure><h3 id="改验证码逻辑"><a href="#改验证码逻辑" class="headerlink" title="改验证码逻辑"></a>改验证码逻辑</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在 login.py文件的第85行 改</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.image_code <span class="hljs-keyword">and</span> ((<br>                                                self.image_code.response == captcha<br>                                                <span class="hljs-keyword">or</span> self.image_code.challenge == captcha<br>                                        ) <span class="hljs-keyword">or</span> captcha.isdigit() <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(captcha) == <span class="hljs-number">6</span>):<br>                    self.image_code <span class="hljs-keyword">and</span> self.image_code.delete()<br>                <span class="hljs-keyword">else</span>:<br>                    self.image_code <span class="hljs-keyword">and</span> self.image_code.delete()<br>                    <span class="hljs-keyword">raise</span> CustomValidationError(<span class="hljs-string">&quot;图片验证码错误&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="再启服务"><a href="#再启服务" class="headerlink" title="再启服务"></a>再启服务</h3><p>执行迁移命令: python3 manage.py makemigrations python3 manage.py migrate<br>初始化数据: python3 manage.py init<br>初始化省市县数据: python3 manage.py init_area<br>启动项目: python3 manage.py runserver 0.0.0.0:8000</p><p>访问地址：[<a href="http://localhost:8000/">http://localhost:8000</a></p><h1 id="前端部署"><a href="#前端部署" class="headerlink" title="前端部署"></a>前端部署</h1><ol><li>进入前端项目目录 <code>cd web</code></li><li>安装依赖 <code>npm install --registry= https://registry.npmmirror.com</code><ol><li>注意一下npm的源 npm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>你可以使用以下命令来查看当前npm的下载源设置：npm config get registry</li><li>安装nodejs &gt;&#x3D; 14.0 (推荐最新)</li></ol></li><li>启动服务 <code>npm run dev</code></li></ol><h1 id="访问项目"><a href="#访问项目" class="headerlink" title="访问项目"></a>访问项目</h1><ul><li>访问地址：<a href="http://localhost:8080/">http://localhost:8080 (opens new window)</a>(默认为此地址，如有修改请按照配置文件)</li><li>账号：<code>superadmin</code> 密码：<code>admin123456</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言之并发编程基础（goroutine、channel、SELECT）</title>
    <link href="/2023/12/07/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88goroutine%E3%80%81channel%E3%80%81SELECT%EF%BC%89/"/>
    <url>/2023/12/07/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88goroutine%E3%80%81channel%E3%80%81SELECT%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="go中的串行和并行还有并发的概念"><a href="#go中的串行和并行还有并发的概念" class="headerlink" title="go中的串行和并行还有并发的概念"></a>go中的串行和并行还有并发的概念</h2><ul><li>串行（Sequential）：<ul><li>串行是一种<strong>执行方式</strong>，串联行走，按照顺序逐一的执行任务或者操作，</li><li>在串行执行中，每个任务必须等待前一个任务执行完了之后才能开始执行</li><li>场景：串行执行通常用于单核或者单线程环境，其中一次只能执行一个任务，意味着任务要找现行顺序执行，一个接一个，直到所有的任务都完成</li><li>串行执行通常具有可预测行，因为任务的执行顺序是确定的，</li><li>缺点就是在多核系统中，无法充分的利用硬件资源</li></ul></li><li>并行（Parallel）：<ul><li>并行也是一种<strong>执行方式</strong> ，</li><li>多个任务或者操作可以同时的执行，不必等待前一个任务完成，</li><li>充分利用多核处理器或者多线程环境的优势</li></ul></li><li>并发（Concurrency）：<ul><li>并发是一个更广泛的<strong>概念</strong>，在同一时间段内处理多个任务，但不一定要求同时执行。在并发中，任务可以交替执行，每个任务都有自己的执行周期，并发通常涉及的是多个独立的执行线程、进程或者协程。</li><li>并发不一定需要多核处理器，它可以在单核处理器上模拟通过快速切换执行线程来实现。</li><li>并发通常用于提高系统的吞吐量、资源利用率和响应性，特别是IO密集型应用中。</li><li>并发任务之间可能需要协调、同步和共享数据，因此需要小心处理并发问题，如竞争条件和死锁等</li></ul></li><li>总结：<ul><li>串行是指按顺序执行任务的方法，不涉及多个任务之间的交替执行</li><li>并行是多个任务同时执行的方式，通常需要多核处理器或多线程环境</li><li>并发是多个任务在同一时间段内处理的方式，可以是交替执行，通常涉及多线程或协程、并需要处理并发相关问题。</li></ul></li></ul><h2 id="【拓展】并发模型"><a href="#【拓展】并发模型" class="headerlink" title="【拓展】并发模型"></a>【拓展】并发模型</h2><ul><li>主流并发模型无外乎三种<ul><li>1、多线程：每个线程一次处理一个请求，线程越多可并发处理的请求数就越多，<ul><li>但是在高并发下，多线程的开销会比较大</li></ul></li><li>2、协程：无需抢占式的调度，开销小，可以有效的提高线程的并发性，从而避免了线程的缺点那部分</li><li>3、基于异步回调的IO模型：异步编程，当遇到密集IO的时候，等待，让其他程序继续跑</li></ul></li></ul><h2 id="goroutine的基本概念"><a href="#goroutine的基本概念" class="headerlink" title="goroutine的基本概念"></a>goroutine的基本概念</h2><ul><li><strong>概念</strong>：是一种<strong>轻量级的线程</strong>，用于执行程序并发任务，与传统线程相比，goroutines更加轻量且消耗更少，</li></ul><p><em>routine:常规；例行程序；日常工作</em></p><p>与创建线程相比，创建成本和开销都很小，每个goroutine的堆栈只有几kb，并且堆栈可根据程序的需要增长和缩小（线程的堆栈是需要指明和固定的），所以go语言从语言层面就支持高并发。</p><ul><li>并发执行：多个goroutines可以同时运行，且不需要显式的线程管理，有助于充分利用多核处理器，提高程序的性能</li><li>轻量级：goroutines比传统线程更轻量。这个轻量可以通俗理解为创建和销毁他们的成本很低，通常数百上千的goroutines可以在同一个程序中运行而不会引发性能问题</li><li>并发通信：goruntines之间的可以通过通道（channel）进行安全的并发通信，通道是goroutines之间交换数据的一种机制，避免了竞争条件和协调任务</li><li>并发模型：Go 语言的并发模型是基于 CSP（Communicating Sequential Processes）的，它强调通过通信来共享数据，而不是共享数据来通信。这种模型使并发编程更加安全和可维护。</li><li>如何<strong>启动 goroutine</strong>：要启动一个goroutine，只需要在函数或方法调用前加上关键字’go’ 即可创建一个新的goroutine来执行该函数，程序继续执行后续任务，而不会等待goroutine完成</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 启动一个 Goroutine 执行 hello 函数</span><br>    <span class="hljs-keyword">go</span> hello()<br><br>    <span class="hljs-comment">// 主线程继续执行其他任务</span><br>    fmt.Println(<span class="hljs-string">&quot;Main function&quot;</span>)<br><br>    <span class="hljs-comment">// 等待一段时间以确保 Goroutine 有足够的时间执行</span><br>    time.Sleep(time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello, Goroutine!&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>程序执行的背后：当程序启动的时候，只有一个goroutine来调用main函数，可以理解为主goroutine，新的goroutine通过go语句进行创建</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DelayPrint</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++ &#123;<br>time.Sleep(<span class="hljs-number">250</span> * time.Millisecond)<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello world goroutine&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> DelayPrint()    <span class="hljs-comment">// 开启第一个goroutine</span><br><span class="hljs-keyword">go</span> HelloWorld()    <span class="hljs-comment">// 开启第二个goroutine</span><br>time.Sleep(<span class="hljs-number">2</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;main function&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><em>tips：DelayPrint里面的sleep ，会导致第二个goroutine阻塞或者等待吗？</em><ul><li>答案肯定是不会</li></ul></li><li>当程序执行go func()的时候，只是简单的调用然后就立即返回了，并不关心函数内部发生的事情，所以不同的goroutine直接不影响，main会继续按顺序执行语句，所以两个go rountine同时在跑，但是肯定是第一个gorounine先执行</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;这是sayHello函数内打印的第%v次\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>) <span class="hljs-comment">// 暂停等待100毫秒</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayWorld</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;world&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;这是sayWorld函数内打印的第%v次\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>) <span class="hljs-comment">// 暂停等待100毫秒</span><br><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// sayHello()</span><br><span class="hljs-keyword">go</span> sayHello() <span class="hljs-comment">//在函数前面加一个go关键字就将这个函数单独的放在一个Goroutine中执行，与主Goroutine并行执行</span><br><span class="hljs-keyword">go</span> sayWorld()<br>fmt.Println(<span class="hljs-string">&quot;这句话先走还是后走&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;yes&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;这是main函数内打印的第%v次\n&quot;</span>, i)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>) <span class="hljs-comment">// 暂停等待100毫秒</span><br>&#125;<br><br><span class="hljs-comment">// time.Sleep(time.Second)</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出内容如下：</span><br><span class="hljs-comment">这句话先走还是后走</span><br><span class="hljs-comment">yes</span><br><span class="hljs-comment">这是main函数内打印的第0次</span><br><span class="hljs-comment">world</span><br><span class="hljs-comment">这是sayWorld函数内打印的第0次</span><br><span class="hljs-comment">hello</span><br><span class="hljs-comment">这是sayHello函数内打印的第0次</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li>这里从输出内容看得出来，当程序碰到go func()的时候，并不管go func()的内容，直接就去执行后面的代码了</li></ul><h2 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h2><p>概念：</p><ul><li>通道是什么：是一种数据结构，所以通道可以用var 来声明数据的类型的</li><li>干什么？：通道是一种在goroutines之间传递的数据结构，它类似于一个<strong>队列</strong>，同于在通道与通道之间<strong>发送和接收数据的</strong></li><li>通道的类型：道中传递的数据必须与通道的类型匹配。通道类型使用 <code>chan</code> 关键字，如 <code>chan int</code> 表示一个整数类型的通道。</li><li>发送和接收：通道的基本操作有发送（<code>send</code>）和接收（<code>receive</code>）。通过通道发送数据时，数据会被发送到通道，然后可以在另一个 Goroutine 中接收。</li><li>阻塞：当发送或接收操作发生时，它们可能会<strong>阻塞</strong>当前 Goroutine，直到有另一个 Goroutine 准备好接收或发送数据。这有助于同步不同 Goroutines 之间的操作。<ul><li><strong>从channel中读取数据，如果channel之前没有写入数据，也会导致阻塞，直到channel中被写入数据为止</strong></li></ul></li></ul><p>强调一下：</p><ul><li>通道是在传递数据，而不是在赋值数据，当通道A 体内的数据，传给了B的时候，A就没有数据了，就空了，B就接收到了B就有了</li></ul><p>接收操作（<code>&lt;-channel</code>）、发送操作（<code>channel &lt;- data</code>）或关闭操作（<code>close(channel)</code>）。</p><p>声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>      <span class="hljs-comment">// 声明一个传递int类型的channel</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 使用内置函数make()定义一个channel</span><br><br>ch &lt;- value          <span class="hljs-comment">// 将一个数据value写入至channel，这会导致阻塞，直到有其他goroutine从这个channel中读取数据</span><br>value := &lt;-ch        <span class="hljs-comment">// 从channel中读取数据，如果channel之前没有写入数据，也会导致阻塞，直到channel中被写入数据为止</span><br><span class="hljs-comment">//=========</span><br><span class="hljs-built_in">close</span>(ch)            <span class="hljs-comment">// 关闭channel</span><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(c))  <span class="hljs-comment">// 通道内实际使用长度，</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(c))  <span class="hljs-comment">// 通道的容积长度，</span><br><br></code></pre></td></tr></table></figure><p>类型：通道理论上来说可以分2种</p><ul><li><p>无缓冲通道和缓冲通道</p></li><li><p>无缓冲通道：无缓冲通道上的<strong>发送</strong>操作将会被阻塞，<strong>直到</strong>另一个goroutine在对应的通道上执行<strong>接收</strong>操作，此时值才传送完成，两个Goroutine都继续执行（发送时阻塞，直到接收才会畅通继续） </p><ul><li>定义的时候，不给大小就是一个无缓冲通道了，ch:&#x3D;make(chan int) int<strong>后面不设容量</strong></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> done <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span> <span class="hljs-comment">//：这里声明了一个名为 done 的布尔类型通道 用来进行通道之间数据通讯</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloWorld</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot; hello world channel&quot;</span>) <span class="hljs-comment">//打印，这里注意下，下面有用</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">500</span>)  <span class="hljs-comment">// 等待500ms</span><br>done &lt;- <span class="hljs-literal">true</span>                        <span class="hljs-comment">// 这里是向done这个channel 发送数据，发送的内容是 true 因为他是一个bool类型的channel 注意，发送数据的时候将会阻塞</span><br>&#125;<br><br><span class="hljs-comment">// func main() &#123;</span><br><span class="hljs-comment">// done = make(chan bool) //  创建一个bool类型的channel 名字叫done 这个通道将用于等待helloWorld函数的完成 分配内存了</span><br><span class="hljs-comment">// go HelloWorld() //启动一个新的goroutine 用来执行helloWorld函数</span><br><span class="hljs-comment">// &lt;-done  // 接收操作，它从 done 通道接收数据</span><br><span class="hljs-comment">// 这个操作会阻塞，直到 HelloWorld 函数发送数据到 done 通道。一旦数据到达，程序将继续执行，然后退出</span><br><span class="hljs-comment">// 如果没有发送和接收通道的操作，那么主goroutine函数main将不会等待goroutine函数helloWorld直接完成就会直接退出mian结束</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)   <span class="hljs-comment">// make就是创建了一个channel类型没有容量（无缓冲）类型的变量名称为ch  后面没设置缓冲通道的大小，就是无缓冲 分配内存了 </span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123; <span class="hljs-comment">// func匿名函数，go是表示他是goroutine 入参是无缓冲channel类型，</span><br>fmt.Println(&lt;-ch) <span class="hljs-comment">// 使用&lt;-channel来接收channel类型 作用是冲通道ch接收数据，并且答应出来，接收到的是多少就打印多少</span><br>&#125;(ch)<br>ch &lt;- <span class="hljs-number">10</span> <span class="hljs-comment">//主函数main将整数10发送到ch通道中，使用&lt;- 用来发送和接收 &lt;-左边是channel就代表想ch发送，&lt;-右边是ch就代表在接收channel</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">总体来说，这段代码的主要目的是创建一个通道 ch，然后启动一个协程，</span><br><span class="hljs-comment">该协程从通道 ch 中接收数据并将其打印到标准输出。</span><br><span class="hljs-comment">同时，主函数将整数值 10 发送到通道 ch 中。由于通道是无缓冲的，</span><br><span class="hljs-comment">这个发送操作会导致协程解除阻塞，接收并打印值 10。因此，你会在标准输出中看到 &quot;10&quot;。这个示例展示了 Go 语言中的并发和通道的基本使用。</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通道可以用来连接goroutine，这样一个的输出是另一个输入。这就叫做管道。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> echo <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> receive <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Echo</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Microsecond * <span class="hljs-number">500</span>)<br>echo &lt;- <span class="hljs-string">&quot;咖啡色的羊驼&quot;</span> <span class="hljs-comment">// 这里在向echo这个通道发送数据</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Receive</span><span class="hljs-params">()</span></span> &#123;<br>temp := &lt;-echo <span class="hljs-comment">// 接收echo通道传过来的数据 这里会阻塞，等待数据传输结束后，</span><br>receive &lt;- temp <span class="hljs-comment">// 将temp接收过来的通道数据，传给receive，</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>echo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>receive = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> Echo()<br><span class="hljs-keyword">go</span> Receive()<br>getStrt := &lt;-receive  <span class="hljs-comment">// 接收 receive 通道传过来的数据 </span><br>fmt.Println(getStrt) <br>&#125;<br><span class="hljs-comment">// 在这里不一定要去关闭channel，因为底层的垃圾回收机制会根据它是否可以访问来决定是否自动回收它。(这里不是根据channel是否关闭来决定的)</span><br></code></pre></td></tr></table></figure><ul><li>单向通道：<ul><li>单向就是指限制一头通信，比如限制仅接收，或者限制仅发送数据</li><li>双向通道可以修改为单向通道，反之不行</li><li>当程序则够复杂的时候，为了代码可读性更高，拆分成一个一个的小函数是需要的。</li></ul></li></ul><p>goroutine的通道默认是阻塞的，那么有什么办法可以去缓解阻塞呢：？</p><p><em>答案：加一个缓冲区</em></p><ul><li>缓冲通道： 一个有容量的通道，可以定义他的容积大小。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 创建了缓冲区为3的通道</span><br><br><span class="hljs-comment">//=========</span><br><span class="hljs-built_in">len</span>(ch)   <span class="hljs-comment">// 长度计算</span><br><span class="hljs-built_in">cap</span>(ch)   <span class="hljs-comment">// 容量计算</span><br><br></code></pre></td></tr></table></figure><p><img src="/img/channel.png" alt="channel"></p><ul><li><strong>当他体内的容积被塞满后，就会阻塞</strong> ，就会死锁</li><li>必须要让通道体内元素个数不大于其设定的容积大小，不然就会报错</li></ul><p>通道有点类似于python的锁一样，谁拿到这个锁，谁就可以操作数据，通道就是谁进去了这个通道，谁就可以操作这个通道内的数据，当这个通道内塞满了的时候，就关门了，进不去了。</p><ul><li>对通道循环取值：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 对channel循环取值</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>) <span class="hljs-comment">// 给ch1这个变量分配了内存（实例化了） 是一个chan，里面的内容是int类型，100个空间</span><br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>ch1 &lt;- i <span class="hljs-comment">// 往这个ch1里面塞数据，把i塞进去了</span><br>&#125;<br><span class="hljs-built_in">close</span>(ch1) <span class="hljs-comment">// 注意要关闭通道</span><br><span class="hljs-comment">// 方式 1 </span><br><br><span class="hljs-comment">// for &#123;</span><br><span class="hljs-comment">// a, err := &lt;-ch1</span><br><span class="hljs-comment">// if !err &#123;</span><br><span class="hljs-comment">// return</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// fmt.Println(a)</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-comment">// 方式 2 </span><br><span class="hljs-keyword">for</span> a := <span class="hljs-keyword">range</span> ch1 &#123;<br>fmt.Println(a)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="goroutine-阻塞死锁和友好退出"><a href="#goroutine-阻塞死锁和友好退出" class="headerlink" title="goroutine 阻塞死锁和友好退出"></a>goroutine 阻塞死锁和友好退出</h2><h3 id="锁："><a href="#锁：" class="headerlink" title="锁："></a>锁：</h3><p>锁用来控制并发访问共享资源的一种同步机制避免多个goroutine同事访问和修改相同的数据，从而导致数据竞争或者不一致的状态，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// 锁的概念与理解</span><br><span class="hljs-comment">// 先创建一个阻塞</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//func main() &#123;</span><br><span class="hljs-comment">//ch1 := make(chan int) // 创建了一个通道ch1 它是个无缓冲通道，容积是0，体内目前数据也是0</span><br><span class="hljs-comment">//&lt;-ch1 //把ch1体内的数据给出去，但是这个时候ch1体内是没数据的，就阻塞（deadlock死锁）了，这个时候阻塞的main函数goroutine ，通道被锁了</span><br><span class="hljs-comment">//// 提示：fatal error: all goroutines are asleep - deadlock!所有的goroutine都睡眠阻塞了，</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">// func main() &#123;</span><br><span class="hljs-comment">// ch1, ch2 := make(chan int), make(chan int) // 创建了两个通道，无缓冲的</span><br><span class="hljs-comment">// go func() &#123;</span><br><span class="hljs-comment">// ch1 &lt;- 1 // 往ch1里面塞了个1</span><br><span class="hljs-comment">// ch2 &lt;- 0 // ch2 里面也塞了个0</span><br><br><span class="hljs-comment">// &#125;() //后面加括号是表示返回值</span><br><br><span class="hljs-comment">// &lt;-ch2 // 把ch2的数据取走，</span><br><span class="hljs-comment">// // 这样运行会阻塞（deadlock死锁），因为往ch1里面塞了一个数据，</span><br><span class="hljs-comment">// // 但是ch1是个无缓冲的通道，现在他的体内被塞了一个数据，如果不把这个数据取走，就会阻塞，</span><br><span class="hljs-comment">// // 反之，ch2的数据被取走了，他体内的数据回到了定义的容积0个，所以它没有阻塞，</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 接下来解锁思路 方式一，把体内数据给出去，让体内数据回到之前定义的大小</span><br><span class="hljs-comment">// func main() &#123;</span><br><span class="hljs-comment">// ch1, ch2 := make(chan int), make(chan int) // 创建了两个通道，无缓冲的</span><br><span class="hljs-comment">// go func() &#123;</span><br><span class="hljs-comment">// ch1 &lt;- 1 // 往ch1里面塞了个1</span><br><span class="hljs-comment">// ch2 &lt;- 0 // ch2 里面也塞了个0</span><br><br><span class="hljs-comment">// &#125;() //后面加括号是表示返回值</span><br><span class="hljs-comment">// &lt;-ch1 //  解锁思路，把ch1的数据也取走给出去，ch1就回到了体内数据为0的状态，这个时候就没阻塞了</span><br><span class="hljs-comment">// &lt;-ch2 // 把ch2的数据取走，</span><br><span class="hljs-comment">// // 这样运行会阻塞，因为往ch1里面塞了一个数据，</span><br><span class="hljs-comment">// // 但是ch1是个无缓冲的通道，现在他的体内被塞了一个数据，如果不把这个数据取走，就会阻塞，</span><br><span class="hljs-comment">// // 反之，ch2的数据被取走了，他体内的数据回到了定义的容积0个，所以它没有阻塞，</span><br><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 接下来解锁思路 方式二，把体内容积扩容，</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1, ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// 创建了两个通道，无缓冲的</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ch1 &lt;- <span class="hljs-number">1</span> <span class="hljs-comment">// 往ch1里面塞了个1 ,这个时候ch1体内数据1小于其容积2，所以不会阻塞</span><br>ch2 &lt;- <span class="hljs-number">0</span> <span class="hljs-comment">// ch2 里面也塞了个0，这个时候ch2体内数据1大于其容积1，如果不把体内数据给出去就会阻塞</span><br><br>&#125;() <span class="hljs-comment">//后面加括号是表示返回值</span><br><span class="hljs-comment">// &lt;-ch1 //  解锁思路，把ch1的数据也取走给出去，ch1就回到了体内数据为0的状态，这个时候就没阻塞了</span><br>&lt;-ch2 <span class="hljs-comment">// 把ch2的数据取走， 这个时候ch2的体内数据回到0，等于其容积，所以不会阻塞</span><br><span class="hljs-comment">// 这样运行会阻塞，因为往ch1里面塞了一个数据，</span><br><span class="hljs-comment">// 但是ch1是个无缓冲的通道，现在他的体内被塞了一个数据，如果不把这个数据取走，就会阻塞，</span><br><span class="hljs-comment">// 反之，ch2的数据被取走了，他体内的数据回到了定义的容积0个，所以它没有阻塞，</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="SELECT-CASE-多路复用"><a href="#SELECT-CASE-多路复用" class="headerlink" title="SELECT + CASE 多路复用"></a>SELECT + CASE 多路复用</h2><ul><li>select语句用于处理并发操作中的多个通道操作，它可以让你同事等待多个通道，并在其中任意一个通道就绪时执行对象的操作</li><li>与switch case语句类似，他有一系列的case分支和一个默认的分支，</li><li>每个分支case<strong>都会对应一个通道的通信</strong>（发送或者接收）过程，select会一直等待，直到某个case的通信操作完成时，就会执行case分支对应的语句，</li><li>如果多个case同时满足，select会<strong>随机</strong>选择一个去运行，</li><li>如果没有满足的case，<strong>则一直等待直到</strong>最后执行default分支，</li><li>如果没有任何通道就绪，<strong>且没有default子句，则sselect语句会阻塞</strong>，直到至少有一个通道就绪。</li><li>select应用场景一：多路复用，通讯，同时监听多个通道，一旦某个通道可以进行读写操作，对应的case语句就会被执行。这种方式可以有效实现多个并发任务之间的协调和同步</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">// ch1 &lt;- 1</span><br><span class="hljs-comment">// select &#123;</span><br><span class="hljs-comment">// case a := &lt;-ch1:</span><br><span class="hljs-comment">// fmt.Println(&quot;走了第一条，如果ch1里面有元素发送给a的情况下，才会走这条路&quot;, a)</span><br><span class="hljs-comment">// case ch1 &lt;- 5:</span><br><span class="hljs-comment">// fmt.Println(&quot;走了第二条，往ch1里面发送一个元素，如果ch1有位置塞数据的话，就会走这条路&quot;)</span><br><span class="hljs-comment">// default:</span><br><span class="hljs-comment">// fmt.Println(&quot;这是最后一条，如果以上都不满足，就会走这里来。&quot;)</span><br><span class="hljs-comment">// &#125;</span><br>ch2 &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> a := &lt;-ch1: <span class="hljs-comment">// 把ch1里的数据发送给a，如果ch1里有数据的话，如果没有就不会触发这条判断</span><br>fmt.Println(<span class="hljs-string">&quot;第一条&quot;</span>, a)<br><span class="hljs-keyword">case</span> ch1 &lt;- <span class="hljs-number">19</span>: <span class="hljs-comment">// ch1接收发送给他的数据19 ， 如果ch1里面还有空位的话，就会触发这一条判断</span><br>fmt.Println(<span class="hljs-string">&quot;走了第二条&quot;</span>)<br><span class="hljs-keyword">case</span> ch2 &lt;- <span class="hljs-number">20</span>: <span class="hljs-comment">// ch2接收发送给他的数据20，如果ch2里面还有空位的话，就会触发这一条判断</span><br>fmt.Println(<span class="hljs-string">&quot;走了第三条&quot;</span>)<br><span class="hljs-keyword">case</span> b := &lt;-ch2: <span class="hljs-comment">// 将ch2里面的数据发送出来给到b，如果ch2里面有数据化，就会触发这一条</span><br>fmt.Println(<span class="hljs-string">&quot;走了第四条&quot;</span>, b)<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 注意下，如果上面的通道都无法满足，且没有定义default，那么select就会阻塞 报错select case must be receive, send or assign recv</span><br>fmt.Println(<span class="hljs-string">&quot;都走不通，就会走这条&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 上面这段代码判断里面,第二条第三条第四条都会满足条件，所以会在这三条判断里面随机走一条</span><br>    <span class="hljs-comment">// 如果没有运行case,就会阻塞事件发送报错（死锁）</span><br>    <span class="hljs-comment">// fatal error: all goroutines are asleep - deadlock!</span><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><ul><li>select 应用的场景二：超时处理，结合selcet和time.After函数，事件对某个操作的超时控制，当某个操作超过一定时间没有完成时，可以执行响应的超时处理逻辑，一下两断代码一个基础版一个简单版的，：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 我们开解析下这段代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>timeOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 定义timeOut为chan，内部类型为bool，容积为1，且分配内存（创建timeOut这个通道） </span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-comment">// func()&#123;代码块&#125;()创建匿名函数</span><br>time.Sleep(time.Second * <span class="hljs-number">1</span>) <span class="hljs-comment">//sleep睡1秒钟</span><br>timeOut &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// 往timeOut这个通道发送一个数据，数据是ture  （bool）</span><br>&#125;()<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// / 定义timeOut为chan，内部类型为int，容积为0，无缓冲通道，且分配内存（创建timeOut这个通道） </span><br><span class="hljs-keyword">select</span> &#123; <span class="hljs-comment">//select case</span><br><span class="hljs-keyword">case</span> &lt;-ch1: <span class="hljs-comment">// 第一个case 将ch1通道里面的数据发出来，但是ch1里面是空的，所以没东西发出来所以不会走这条case</span><br><span class="hljs-keyword">case</span> &lt;-timeOut: <span class="hljs-comment">// 第二个case，把timeOut通道里面的数据发出来，因为timeOut里面有个ture这个数据，所以满足，会走这条case </span><br>fmt.Println(<span class="hljs-string">&quot;超时了，走了这一步&quot;</span>) <span class="hljs-comment">// </span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>下面这个是常用的简化版的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs GO"><span class="hljs-comment">// 简化写一个通俗版，这段代码原理和上面类型，但有个小技巧，我们解读一下</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 创建ch1通道，容积为0</span><br>ch1 &lt;- <span class="hljs-number">8</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1: <span class="hljs-comment">// 从ch1通道读取数据（把ch1的数据发送出来），ch1为空，不满足该判断</span><br>fmt.Println(<span class="hljs-string">&quot;没有超时就会走这条路&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second * <span class="hljs-number">1</span>): <span class="hljs-comment">// 这里会有疑问的：因为这里的函数time.After()的返回值就是一个有数据的通道，所以满足该case判断</span><br><span class="hljs-comment">// 翻看源码就知道：func After(d Duration) &lt;-chan Time &#123;return NewTimer(d).C &#125;返回的是一个chan类型 Time</span><br>fmt.Println(<span class="hljs-string">&quot;超时1秒且走了这条路&quot;</span>)<br><span class="hljs-comment">// 这里要注意一下，time.After必须要等待时间结束后才会返回一个chan，如果在等待时间内，有其他case满足了，就会去运行其他case.</span><br><br>&#125;<br><span class="hljs-comment">// ch1 &lt;- 8 // 我们试一下往这个ch1里塞一个数据，让他满足第一个case的判断。在Second*1的时间内。满足了第一个case，所以不会运行打印第二个case的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>select 场景三：非阻塞通信，通过定义default语句，实现非阻塞的通信操作，当没有任何通信操作可以立即进行时，default语句会被执行，可以写一下默认逻辑。（判断channel是否阻塞(或者说channel是否已经满了)）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span> (<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 注意这里给的容量是1</span><br>ch &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-number">2</span>:<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 走到这里说明select case阻塞了，因为通道满了</span><br>fmt.Println(<span class="hljs-string">&quot;通道channel已经满啦，塞不下东西了!&quot;</span>) <br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>slelect场景四：.退出机制</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 解读下这段代码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span>                      <span class="hljs-comment">// 初始化i 值为1</span><br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 创建一个通道，内容为字符串，容积为0</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;              <span class="hljs-comment">// defer main函数结束的时候执行这个方法</span><br><span class="hljs-built_in">close</span>(ch1) <span class="hljs-comment">// 关闭通道</span><br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">// goroutine执行匿名方法</span><br>DONE: <span class="hljs-comment">// DONE:只是在打标签，标记一下循环开始了，没有实际作用</span><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">1</span>) <span class="hljs-comment">// 暂停一秒</span><br><span class="hljs-comment">// fmt.Println(time.Now().Unix()) // 打印Unix时间戳</span><br>fmt.Println(time.Now().UTC()) <span class="hljs-comment">// 打印UTC国际标准时间</span><br>i++                           <span class="hljs-comment">// 循环一次 加等与1</span><br><br><span class="hljs-keyword">select</span> &#123; <span class="hljs-comment">// 开启select case</span><br><span class="hljs-keyword">case</span> m := &lt;-ch1: <span class="hljs-comment">// 将ch1里面的数据给m变量，但是ch1里是空的，所以不会触发这个</span><br>fmt.Println(<span class="hljs-string">&quot;打印ch1里面的内容 :&quot;</span>, m) <span class="hljs-comment">// 打印接收通道数据的m,就是下面的stop会被塞进来</span><br><span class="hljs-comment">// 这里的DONE也是一个意思标记一下循环从这里结束，收尾呼应</span><br><span class="hljs-keyword">break</span> DONE <span class="hljs-comment">// 当这个通道里面有内容时，结束这个无限循环</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// 没有通道满足case，触发default 打印下面的话</span><br>fmt.Println(<span class="hljs-string">&quot;以上买满足的条件&quot;</span>)<br>&#125;<br>&#125;<br>&#125;()<br>time.Sleep(time.Second * <span class="hljs-number">5</span>)   <span class="hljs-comment">// 会一直等5秒，但是等待的时候，go func匿名函数里面的死循环会一直去循环</span><br>ch1 &lt;- <span class="hljs-string">&quot;stop,塞进通道里面去&quot;</span>         <span class="hljs-comment">// 五秒结束，往 ch1通道里面塞了一个数据 &quot;stop&quot; , ch1里面塞数据的时候，等待到无限循环里面就会被终止的</span><br>fmt.Println(<span class="hljs-string">&quot;看一下这段代码在什么时候执行&quot;</span>) <span class="hljs-comment">// 这个是在循环结束后才会执行</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>强调一下： 要跳出循环，一定要用break+ 具体标记，或者goto 标记也可以，否则其实不是真的退出，因为在goroutine里面，会不停地跑</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>fmt.Println(time.Now().Unix())<br>i++<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> m := &lt;-ch:<br><span class="hljs-built_in">println</span>(m)<br><span class="hljs-keyword">goto</span> DONE <span class="hljs-comment">// 跳出 select 和 for 循环</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br>DONE:<br>&#125;()<br><br>time.Sleep(time.Second * <span class="hljs-number">4</span>)<br>ch&lt;-<span class="hljs-string">&quot;stop&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是一种同步机制，用于控制对共享资源的访问，确保一次只有一个goroutine可以反问共享资源。</p><p>锁有两种状态：锁定和解锁，一旦有一个goroutine获得了锁，那其他goroutines将被阻塞。直到锁被释放</p><p>锁：互斥锁、读写锁</p><h2 id="锁（互斥锁）简单解析"><a href="#锁（互斥锁）简单解析" class="headerlink" title="锁（互斥锁）简单解析"></a>锁（互斥锁）简单解析</h2><p>互斥锁：在并发执行时，多个goroutine同事读写一个数据，就会造成数据的读写混乱，</p><p>解决方式：加锁，加互斥锁，</p><p>方式：控制对共享资源的访问，让它可以却道在任何给定的时刻都只有一个线程或者说goroutine能够访问到被保护的临界区。 </p><p>每一个</p><p>channel通道是解决协程同步，锁是解决协程（线程）访问资源优先性，</p><p>使用互斥锁时一定要注意，对资源（文件、数据等）操作完成</p><p>弊端：加了互斥锁之后，并发就变成了串行了，或者说，走到此处时，是串行，牺牲了效率，但是保证了数据安全性</p><h3 id="互斥锁等待组"><a href="#互斥锁等待组" class="headerlink" title="互斥锁等待组"></a>互斥锁等待组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span>             <span class="hljs-comment">// 定义了一个整形变量</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// 定义了一个等待组WaitGroup</span><br><span class="hljs-keyword">var</span> lock sync.Mutex   <span class="hljs-comment">// 定义了一个Mutex互斥锁</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>lock.Lock() <span class="hljs-comment">// 开启锁</span><br>fmt.Println(<span class="hljs-string">&quot;x开始前为=&quot;</span>, x)<br>x++<br>fmt.Println(<span class="hljs-string">&quot;x此时为=&quot;</span>, x)<br>lock.Unlock() <span class="hljs-comment">// 关闭锁</span><br>&#125;<br>wg.Done() <span class="hljs-comment">// 通知等待组wg完成了</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;x=&quot;</span>, x)<br>wg.Add(<span class="hljs-number">2</span>) <span class="hljs-comment">// 等待组添加了2个 就是把两个goroutine放进等待组里面，他们两个在抢锁</span><br><span class="hljs-comment">// 两个add方法都在同时运行，但是只有一把锁，谁拿到了锁就是谁在执行x++的这个操作</span><br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br><span class="hljs-comment">// go add()</span><br>wg.Wait() <span class="hljs-comment">// 等待组进入等待状态，等这两个goroutines完成任务</span><br>fmt.Println(x)<br>&#125;<br><span class="hljs-comment">// 输出为2000 </span><br></code></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><ul><li>场景：读多写少，读是不需要加锁的，写需要加锁</li><li>解决：读写互斥锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">- 当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁，就会等待；<br>- 当一个<span class="hljs-string">`goroutine`</span>获取写锁之后，其他的<span class="hljs-string">`goroutine`</span>无论是获取读锁还是写锁都会等待<br></code></pre></td></tr></table></figure><h2 id="sync-Map-并发安全映射（Map）"><a href="#sync-Map-并发安全映射（Map）" class="headerlink" title="sync.Map 并发安全映射（Map）"></a>sync.Map 并发安全映射（Map）</h2><ul><li>Go内置的map 并不是并发安全的，所以高并发下使用sync.Map类型</li><li>sync.Map不需要使用make()分配内存，使用另一种便捷方式：Store&#x2F;Load等</li></ul><p>1、并发安全性：<code>sync.Map</code> 在多个goroutines之间提供了并发安全的读取和写入操作，这意味着你可以同时在多个goroutines中访问和修改同一个映射，而不需要额外的锁或者同步机制去限制</p><p>2、自动扩容：<code>sync.map</code>在需要时会自动扩容以适应更多的键值对，无需手动管理容量问题</p><p>3、性能优化：<code>sync.map</code>在内部使用了一些性能优化策略，以提高并发访问的性能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// // 写入键值对</span><br><span class="hljs-comment">// m.Store(&quot;key1&quot;, &quot;value1&quot;)</span><br><span class="hljs-comment">// m.Store(&quot;key2&quot;, &quot;value2&quot;)</span><br><br><span class="hljs-comment">// // 读取键的值</span><br><span class="hljs-comment">// value, found := m.Load(&quot;key1&quot;)</span><br><span class="hljs-comment">// if found &#123;</span><br><span class="hljs-comment">// fmt.Println(&quot;Value:&quot;, value)</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// // 删除键值对</span><br><span class="hljs-comment">// // m.Delete(&quot;key2&quot;)</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123; <span class="hljs-comment">// 循环10次，10个goroutine</span><br>wg3.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">// 添加等待组，添加1个，循环了i遍</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n) <span class="hljs-comment">//将n转化成字符串，用key接收，Itoa转换</span><br>m.Store(key, n)        <span class="hljs-comment">// 组装一个sync.Map 键是kyc字符串，值是n，所以就是 &quot;1&quot;:1这样的形式</span><br><span class="hljs-comment">//读取sync,Mao的内容，通过Key拿值，</span><br><span class="hljs-comment">// 下划线表示不处理那个返回值，Load会返回两个值，前面的是kyc对应的value，后面的是一个布尔值，有就真，无就假</span><br>value, _ := m.Load(key)<br>fmt.Println(value) <span class="hljs-comment">//打印的是key 的值</span><br>wg3.Done()         <span class="hljs-comment">// 结束这个等待组</span><br><br>&#125;(i)<br>wg3.Wait() <span class="hljs-comment">// 等待所有等待组完成</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言之接口(interface)</title>
    <link href="/2023/12/06/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8E%A5%E5%8F%A3(interface)/"/>
    <url>/2023/12/06/go%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%8E%A5%E5%8F%A3(interface)/</url>
    
    <content type="html"><![CDATA[<h1 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h1><h2 id="关于接口的概念"><a href="#关于接口的概念" class="headerlink" title="关于接口的概念"></a>关于接口的概念</h2><ul><li><p>接口interface是定义了一组方法的集合，</p></li><li><p>接口提供了一种标准化的方式，用来规定对象的行为，。</p></li><li><p>通过接口，你定义了对象必须具备的方法。而不必关心对象的具体实现。这种抽象的方式，可以更加灵活和复用</p></li><li><p>通过定义接口interface，然后让对象来调用或者实现</p></li><li><p>接口interface可以作为函数的入参参数，也可以作为返回值 实现多态</p></li><li><p>接口Interface 是一种规范，是一种限制，</p></li></ul><p> <strong>当你把接口interface定义好后，作为入参，那你这个函数的入参，就必须有你定义的接口interface有的方法，不然就会报错，</strong></p><ul><li><p>同理你把interface类型的东西作为return出去的东西，那你就在定义return的对象时就必须定义他有哪些方法，</p></li><li><p>总的说，接口等同于python的基类，基类用于子类必须实现方法，接口也是子类必须实现方法。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123; <span class="hljs-comment">//在定义接口interface类型，这个类型有一个say方法</span><br>say()<br>&#125;<br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 结构体</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// 结构体</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span></span> say() &#123; <span class="hljs-comment">// 这个是方法，结构体的方法</span><br>fmt.Printf(<span class="hljs-string">&quot;%v小花猫，喵喵叫\n&quot;</span>, c.Name)<br>&#125;<br><br><span class="hljs-comment">// 这两个结构体都有say方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span></span> say() &#123; <span class="hljs-comment">// 这个say也是方法，结构体的方法</span><br>fmt.Printf(<span class="hljs-string">&quot;%v小土狗，汪汪叫\n&quot;</span>, d.Name)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aaa</span><span class="hljs-params">(a animal)</span></span> <span class="hljs-type">string</span> &#123; <span class="hljs-comment">//这个方法的入参是一个animal接口类，所以传进来的参数必须要是animal类型，必须要有say方法</span><br>a.say()<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;aaa&quot;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bbb</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> animal &#123; <span class="hljs-comment">// 这是在定义一个返回值为interface接口类型的函数</span><br><span class="hljs-comment">//a.say()</span><br><span class="hljs-comment">//a.say()</span><br>c := cat&#123;<span class="hljs-string">&quot;小白&quot;</span>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := cat&#123;<span class="hljs-string">&quot;小白&quot;</span>&#125;    <span class="hljs-comment">//这个C是cat结构体的实例化对象</span><br>d := aaa(c)       <span class="hljs-comment">//这个d是函数aaa的实例化对象 需要传入参，入参就是C 且这个入参必须要有say方法，不然就会报错</span><br>fmt.Printf(d)     <span class="hljs-comment">//打印这个d，此时d是有返回值string的所以可以打印出来</span><br>e := bbb(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">//这是在实例化bbb函数，e就是上面的c，是一个interface接口类型的。</span><br>e.say()           <span class="hljs-comment">// e是不可以直接打印的，因为你无法打印接口类型。但是你可以调用这个interface接口的方法</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="接口也是一种类型，可以定义变量"><a href="#接口也是一种类型，可以定义变量" class="headerlink" title="接口也是一种类型，可以定义变量"></a>接口也是一种类型，可以定义变量</h1><ul><li>结构体—结构体方法—接口</li><li>接口类型的变量，能够储存所有实现了该接口的结构体。</li><li>实例化一个变量（对象）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c cat)</span></span> say() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v小猫喵喵叫\n&quot;</span>, c.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dog)</span></span> say() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v小狗汪汪叫\n&quot;</span>, d.Name)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a animal<br>fmt.Printf(<span class="hljs-string">&quot;类型是:%T\n&quot;</span>, a)    <span class="hljs-comment">//打印的类型是nil 类型</span><br>fmt.Printf(<span class="hljs-string">&quot;打印的内容是:%v\n&quot;</span>, a) <span class="hljs-comment">// 这个a 是一个接口类型的实例化对象，所以打印是没有数据的 打印的是nil</span><br>c := cat&#123;<span class="hljs-string">&quot;小花&quot;</span>&#125;<br>a = c          <span class="hljs-comment">//这个时候把c赋值给了a，所以a有c的属性</span><br>fmt.Println(a) <span class="hljs-comment">//所以打印的时候，就可以打印a了，</span><br>a.say()<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="定义指针类型和值类型接收器实现接口"><a href="#定义指针类型和值类型接收器实现接口" class="headerlink" title="定义指针类型和值类型接收器实现接口"></a>定义指针类型和值类型接收器实现接口</h1><ul><li>值类型接口实现后，不管是结构体还是结构体指针的变量，都可以赋值给接口变量</li><li>只要是值接收器，修改的都是新的。</li><li>使用指针接收器实现接口之后，只能将结构体指针变量赋值给该接口变量</li><li>只要是指针接收器，修改的都是原来的。、</li></ul><p><strong>你在定义结构体方法的时候，将入参定义为指针类型入参即可，</strong></p><p><strong>这样你在实例化这个结构体的时候，传入指针类型即可</strong> </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言之json、YAML的序列化和反序列化</title>
    <link href="/2023/12/06/11.1%20go%E8%AF%AD%E8%A8%80json%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/12/06/11.1%20go%E8%AF%AD%E8%A8%80json%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="11-1-json序列化"><a href="#11-1-json序列化" class="headerlink" title="11.1 json序列化"></a>11.1 json序列化</h1><p>Go语言中的序列化和反序列化是一种解码<strong>思路</strong></p><p>可以将结构体进行序列化为<strong>JSON字符串格式</strong>，</p><p><code>注意：不是将类型转化为JSON，go语言没有JSON格式类型，</code></p><p>是将数据，转化为 JSON格式风格的数据，供其他语言使用，</p><p>比如说，python中，也没有json这种数据格式，把一串json导入到Python，打印它的类型，打印出来就是string字符串类型，将json转化成字典，就是将字符串转成字典</p><p>带入到go语言中也是一样的概念，只是go语言可以通过结构体去转化成json(序列化)，变成一种键值对的格式（也有不是键值对格式的json）</p><p>go语言序列化（结构体转json）和反序列化的实现方式：通过json.Marshal(person) person就是结构体实例化的数据，json.Unmarshal(jsondata)就是反序列化（结构体转json）</p><p>结构体转JSON</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Myaccount <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>PWD    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;pwd&quot;`</span><br>Amount <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;amount&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>account := Myaccount&#123;<span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">18</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;打印一下：&quot;</span>, account) <span class="hljs-comment">// 打印一下： &#123;and 123 18&#125;</span><br><span class="hljs-comment">// 序列化方法</span><br>data1, _ := json.Marshal(account)<br>    fmt.Println(<span class="hljs-string">&quot;序列化后的data1:&quot;</span>, <span class="hljs-type">string</span>(data1)) <span class="hljs-comment">// 序列化后的data1: &#123;&quot;name&quot;:&quot;and&quot;,&quot;pwd&quot;:&quot;123&quot;,&quot;amount&quot;:18&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, data1) <span class="hljs-comment">// 打印出来的类型是无符号8位整形[]uint8，无正负符号8位整形</span><br>data2, _ := json.MarshalIndent(account, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<span class="hljs-comment">// MarshalIndent带缩进</span><br><br>fmt.Println(<span class="hljs-string">&quot;序列化后的data2=&quot;</span>, <span class="hljs-type">string</span>(data2))    <span class="hljs-comment">// 序列化后的data2= &#123;</span><br> <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;and&quot;</span>,<br> <span class="hljs-string">&quot;pwd&quot;</span>: <span class="hljs-string">&quot;123&quot;</span>,<br> <span class="hljs-string">&quot;amount&quot;</span>: <span class="hljs-number">18</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;data2的格式是：%T\n&quot;</span>, data2) <span class="hljs-comment">// []uint8</span><br><span class="hljs-comment">// 反序列化方法，就用json.Unmarshal()方法</span><br><span class="hljs-keyword">var</span> account2 Myaccount <span class="hljs-comment">// 定义一个变量account2，类型是Myaccount结构体</span><br>json.Ummarshal(data1,&amp;account2)<br>fmt.Println(<span class="hljs-string">&quot;account2=&quot;</span>, account2)<span class="hljs-comment">// account2=&#123;and 123 18&#125; ,打印出来的就是结构体了</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, account2) <span class="hljs-comment">// 类型就是main.Myaccount</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 再写一个</span><br><span class="hljs-keyword">type</span> MyScore <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Class <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;class&quot;`</span><br>Score <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    TomScore := MyScore&#123;<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;2班&quot;</span>, <span class="hljs-number">99</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;TomSocre=&quot;</span>, TomScore)<br><span class="hljs-comment">// 将TomScore进行序列化</span><br>JsonTomScore, _ := json.Marshal(TomScore)<br>fmt.Println(<span class="hljs-string">&quot;JsonTomScore=&quot;</span>, <span class="hljs-type">string</span>(JsonTomScore))<br><span class="hljs-comment">// 优化缩进后的</span><br>JsonTomScore2, _ := json.MarshalIndent(TomScore, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot; &quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;JsonTomScore2=&quot;</span>, <span class="hljs-type">string</span>(JsonTomScore2))<br><span class="hljs-comment">// 反序列化</span><br><span class="hljs-keyword">var</span> tom MyScore<br>json.Unmarshal(JsonTomScore, &amp;tom)<br>fmt.Println(<span class="hljs-string">&quot;tom=&quot;</span>, tom)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>序列化和反序列化，目前用到的是结构体类型数据转成json格式，和json格式转成结构体类型的数据</p></blockquote><h1 id="Yaml-序列化和反序列化（yaml与结构体互转）"><a href="#Yaml-序列化和反序列化（yaml与结构体互转）" class="headerlink" title="Yaml 序列化和反序列化（yaml与结构体互转）"></a>Yaml 序列化和反序列化（yaml与结构体互转）</h1><ul><li>思路和方式跟json的是一样的，只是用了一个库：**”gopkg.in&#x2F;yaml.v3”**</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;gopkg.in/yaml.v3&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyYAML <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;name&quot;`</span><br>Age   <span class="hljs-type">int</span>    <span class="hljs-string">`yaml:&quot;age&quot;`</span><br>Email <span class="hljs-type">string</span> <span class="hljs-string">`yaml:&quot;email,omitempty&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 序列化yaml 和序列化json一样的  yaml.Marshal</span><br>YamlStruct := MyYAML&#123;<span class="hljs-string">&quot;andy&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;110@163.com&quot;</span>&#125;<br>fmt.Println(<span class="hljs-string">&quot;YamlStruct=&quot;</span>, YamlStruct)<br>YamlDate, _ := yaml.Marshal(YamlStruct)<br>fmt.Println(<span class="hljs-string">&quot;YamlDate=&quot;</span>, <span class="hljs-type">string</span>(YamlDate))<br><span class="hljs-comment">// 下面反序列化yaml,也是和json一样思路，yaml.UnMarshal</span><br><span class="hljs-comment">// 不过在这之前你要有一个yaml文件，读取这个yaml文件后才能去打印出来</span><br>yamlDataFile, err := ioutil.ReadFile(<span class="hljs-string">&quot;data.yml&quot;</span>) <span class="hljs-comment">// 读取yml文件</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to read YAML file: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">var</span> MyYamlStruct MyYAML<br>err = yaml.Unmarshal(yamlDataFile, &amp;MyYamlStruct) <span class="hljs-comment">// 把数据赋值到结构体里，用指针，改变他的值</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to unmarshal YAML: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-comment">// 打印数据出来，</span><br>fmt.Printf(<span class="hljs-string">&quot;Name: %s, Age: %d, Email: %s\n&quot;</span>, MyYamlStruct.Name, MyYamlStruct.Age, MyYamlStruct.Email)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/05/hello-world/"/>
    <url>/2023/12/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
